http://cs106b.stanford.edu/about_assessments
"This page is currently under construction! More information about the mid-quarter and end-of-quarter assessments will be posted here soon.   "
http://cs106b.stanford.edu/about_assignments
"We have a great set of assignments planned that follow up on the material presented in lecture and section. Programming is a skill best learned by doing, so the assignments form an integral part of your experience in the course. These projects will be fun, challenging, illuminating, and rewarding. Your sense of pride upon finishing is well deserved and your efforts earn you powerful skills and deep understanding.  Common questions about assignments  What programming environment and tools are used?  We will be using Qt Creator, which is an IDE for writing and building C++ programs. Please visit the Qt Installation Guide for further instructions on how to download and install Qt Creator.  What is the assignment schedule?  Our schedule plans for one assignment each week, due weekly on Friday at 11:59pm AoE (Anywhere on Earth).  What is the expected assignment workload? Depending on the week's topics, the accompanying assignment may consist of written problems, hands-on exercises with the tools, targeting coding tasks, and/or a larger complete program.  Students self-report spending between 8 and 15 hours on each assignment.  What is the policy on late assignments?  Students are automatically given a penalty-free 48 hour extension on all assignments. Read our course late policy for the details.  What is the assignment collaboration policy?  The assignments are to be done individually and should represent independent, original work. We adhere to the Stanford and CS department Honor Code policies. Please review our Honor Code handout to see specific examples of its application to coursework in this course.  How can we get help on our assignments? The instructor and head TA will hold office hours (Zoom). The course helpers and section leaders staff regular LaIR helper hours (Zoom).  Our online forum allows public Q&amp;A and discussion with your peers. Please participate!  How are assignments evaluated? Programs will be graded on \"functionality\" (is the program's behavior correct?) and \"style\" (is the code well written and elegant?). The evaluation for each category uses this bucket scale:          +    Exceeds our expectations, is effectively \"perfect\". WOW! To receive this grade, a program often reflects additional work beyond the requirements or gets the job done in a particularly elegant way.           ✓+   Satisfies all the requirements for the assignment, showing solid functionality as well as good style. Nice job!           ✓   Meets the requirements for the assignment, with a few small problems or areas of improvement. Solid work           ✓-   Has problems serious enough to fall short of the requirements for the assignment. Needs improvement.           -   Has extremely serious deficiencies, does not demonstrate significant effort and understanding. Danger           0    Not submitted.      How do we receive feedback from our grader? One great feature of the CS106 courses is that your programs are graded interactively in a one-on-one session with your section leader so you get targeted feedback for individual improvement.  Your section leader will explain in section how to schedule these sessions and go over the grading process in more detail. "
http://cs106b.stanford.edu/about_course
"CS 106B, Programming Abstractions is the follow-on course to CS 106A. It is taught in C++, although students are only expected to know some Python (or other object oriented language) before enrolling in the course. That said, if you are taking CS 106B without taking CS 106A, you should probably look at the Course Placement handout from the website to see if you are in an appropriate course.  The major learning goals for the course are:     To learn how to model and solve complex problems with computers.   To explore common abstractions for representing problems.   To learn how to harness recursion and understand how to think about problems recursively.   To quantitatively analyze different approaches for solving problems.   To learn to use the most efficient data structures and methods (e.g., by using recursion, when appropriate) to solve problems.   To learn how to efficiently debug programs using an Integrated Development Environment.   Topics covered include:    An introduction to the C++ language.   Common containers, including vector, stack, queue, set, and map.   Common data structures, including linked lists, heaps, trees, hash tables (and hashing in general), and graphs.   The art of recursion.   Sorting   Introduction to orders of approximation (\"Big O\") and asymptotic analysis.   C++ Classes.   We will have regular lectures during the 2:30 - 3:30 PDT (GMT -7) time frame. All lectures will be available live on Zoom, and also recorded for download or viewing after class.  There will be approximately one programming assignment per week, done on an individual basis, and the programming assignments will, in total, cover most of the topics listed above.  Students will be assigned to a small (10-13 person) recitation section that will meet once a week, via Zoom. Sections are led by Section Leaders, who have been through the CS 106 program and will help students digest the course material and will walk through practice programming problems. All sections will be taught online, and we expect to have enough sections to cover most time zones at a reasonable time of day.  The class will have online office hours (the LaIR), and there will be a relatively large window of opportunity to get online help.  There will be a mid-quarter and final assessment, though neither will be a traditional exam.  The course will be taught with a Satisfactory / No Credit grading scheme for all students, as per the university directive for all courses during Spring 2020.  "
http://cs106b.stanford.edu/about_lectures
"   Lectures will be delivered via Zoom Webinars, at the scheduled time (MWF 2:30pm PDT, GMT-7)   You are welcome to participate in live lectures via the Zoom links provided on Canvas. Students will be able to ask questions during lecture, which will be moderated by members of the course staff.   If you able to participate in the live lecture, there will also be a short 10-15 minute Zoom meeting hosted after class every day, where you can come and ask the course staff questions about the recently concluded lecture. Zoom links to these meetings are also provided on the course Canvas page.   You are also welcome to watch lectures at any time after the scheduled time. We are working on ensuring that the lecture videos are posted soon after each class ends.    Common questions about lectures   What tools will I need? If you want to watch the video live, you should be able to use Zoom in some form or another. It would be best to have a video feed if watching live. I.e., calling in from your phone would work, but seeing the slides and code in real-time is going to be beneficial. If you must call in, you should also try to have the slides up on your computer at the same time. Alternatively, you can download the videos after the class ends, and watch them without an Internet connection.  How can I ask a question on a Webinar? You can pose questions using the Zoom Q&amp;A feature, which will be moderated by the members of the course staff that are not lecturing.  What if I live in a time zone such that is inconvenient to watch the class live? You can download the videos to watch at any time after the class meeting time (after we have posted them).  Can I run code examples myself? Yes - we will either have a Qt project for you to download, or you should be able to keep a blank project open in Qt and type the code as we do. In general, we advise against doing this during class, but if you are watching the video and want to pause the video to test the code, that would work well.  "
http://cs106b.stanford.edu/about_section
"Each week, you'll meet for about an hour in a small discussion section. Each discussion section will be led by your assigned section leader, who will act as your mentor, grader, and personal connection to the greater CS106B course staff. Your section leader will help you review the material that has been introduced in lecture, explore topics in more depth, and generally answer questions any questions that you may have.  For every section, there will be a handout of section problems focusing on the material from that week of lecture. These section problems are designed to give you  extra practice with the course material. You're not expected to complete these problems before attending section and we won't be grading them for credit. Instead, think of them as a resource you can use to practice with the material as you see fit. You're not expected to cover all the problems in a given handout during section, so we strongly recommend using the problems you didn't complete as extra practice. Solutions will be released to all section problems every Friday evening after all sections have been completed.  Attendance and participation in section will be mandatory for all students. Your section leader will be grading your participation in section on a weekly basis, and these grades will make up 10% of your final grade. Participation in section can take many forms, including asking questions, contributing answers, and participating in discussions with fellow students. We will be providing section times that run from 8:30am to 8:30pm PDT, so we are hopeful that all students will be able to find a section time that works for them. If you have concerns about your ability to attend and participate in section, due to any factor (time zone, technological barriers, etc.) please email Nick (nbowman@stanford.edu) and he can work with you to arrange necessary accommodations.   Common questions about sections  How do I sign up for section? Section signups will be conducted on the CS198 website. Section signups will open on Thursday, April 9 at 5pm PDT and will close on Sunday, April 12 at 5pm PDT. Unlike Hamilton tickets, section sign-ups are not first-come first-serve, so don't worry about rushing to fill out your preferences as soon as the form opens - just make sure to submit your preferences before the window closes! After a matching process, your section assignments will be emailed out to you by the evening of Tuesday, April 14. Sections begin the second week of classes. Note that you should only sign up for sections at the URL indicated previously (you should not sign-up for sections on Axess).  Is section attendance mandatory? Yes, attendance and participation in section will be graded and will make up 10% of your final grade in the class. As per course policy, students must earn a passing grade in every core component of the class in order to pass the overall class, so we expect that students will regularly attend section and participate with a high level of engagements. If you have concerns about this policy as it related to your personal situation, please email Nick.  How will section participation be graded? Section participation will be graded every week on a scale from 0 to 2. The grades will be assigned as follows:    2 : Showed up to section on time, followed section norms, participated in an engaged manner   1 : Showed up to section late, minimal participation   0 : Did not show up to section, or did not follow established section norms and policies   Where can I find the section problems? Where can I find the solutions? The section problems will be posted on the course website under the \"Sections\" tab of the navigation bar at the beginning of every week. At the end of every week (on Friday evening), the section handout will be updated with the solutions.  What tools will I need for section? Is there anything I need to set up or know going in? Similar to lectures, section will be conducted virtually over Zoom. You can find your assigned section time and Zoom meeting information on Paperless. Folks within the CS198 program have put together this very helpful Guide to Section for Students - make sure to check that out for section tips and FAQs!  Where can I find my section Zoom information? You can find the Zoom information for your assigned section on Paperless.  What should I do if I miss one of my sections? If you miss your section in a given week, you can attend another section that week to makeup your absence. Make sure to let the section leader whose section you attend know that you're there so that they can let your section leader know that you attended. A list of all section times (and corresponding Zoom information for each section) can be found on this page. "
http://cs106b.stanford.edu/about_staff
"                      Lecturer: Chris Gregg ✉️cgregg@stanford.edu                         Lecturer: Julie Zelenski ✉️zelenski@stanford.edu                         Head TA: Nick Bowman ✉️nbowman@stanford.edu                                   aamnah khalid                          abdu mohamdy                          ahmed abdalla                          alex bucquet                          alice yang                          allie littleton                          amir zur                          anna ekholm                          avery wang                          baker sharp                          brian zeng                          colin kincaid                          david liu                          david wu                          drew bassilakis                          ella tessier lavigne                          emilia darmstadt                          eric bear                          ethan chi                          frankie cerkvenik                          hannah zhang                          jacob tie shue                          james mayclin                          jeremy barenholtz                          jerry chen                          jillian tang                          jonathan kula                          jr ereyi                          julio ballista                          justin tinker                          kaitlin hsu                          katherine wu                          kathleen mhatre                          keegan mehall                          kimberly batdorf                          kinbert chou                          lauren saue fletcher                          matthew kolodner                          maya ziv                          oliver brady                          patrick demichele                          peter hansel                          rachel gardner                          richard lin                          robbie selwyn                          ryan cao                          sam spinner                          sidhika balachandar                          thariq ridha                          tommy yang                          trip master                          zheng lian           Common questions about section leading   How do I become a section leader someday? You can apply during/after completing 106B. Come join us! Application information can be found on the CS 198 Website. "
http://cs106b.stanford.edu/all_announcements.html
"      Section Assignments 4 days ago by Nick  Section assignments have been made. Students who filled out the section signup on time should have received an email with details of their section. If your section time no longer works for you or you were unable to sign up for a section in time, visit the CS198 Website to join a section.  This page will also have a link to a list of all the section times for students wishing to make up a missed section. Note that section participation is required for all enrolled students in CS 106B.       Free Online CTL Tutoring 5 days ago by Nick  We've been asked to share this message on behalf of the Center for Teaching and Learning:     Want to meet with an experienced peer to discuss course concepts, think through a problem set, or prepare for an upcoming exam? CTL offers appointment tutoring for CS 106B, in addition to tutoring for a number of other courses. For more information and to schedule an appointment, visit our tutoring appointments and drop-in schedule page. We also have a variety of remote learning opportunities and academic coaching available to assist with all of your learning needs!        Assignment 1 Released 1 week and 1 day ago by Nick  Assignment 1 has now been released! In this assignment, you will get practice with C++ fundamentals, including functions, return, decomposition, strings, as well as good testing and debugging practices. Check out the assignment page for more info!       Section Signups, Qt Installation Help, and Other Logistics 1 week and 3 days ago by Nick  Here are the last set of important logistical announcements for this week:          Section signups are now live! To fill out your section time preferences, head on over to the CS198 website. Remember, everyone (including SCPD students) is required to join a section for this class, as this is how you get assigned a section leader that will be responsible for grading your assignments and conducting your assessments. You will be able to input and change your section preferences until Sunday, April 12 at 5pm PDT. After this point, the portal will temporarily close while assignments are being made. Section assignments will be released to you on Tuesday of next week, and sections will begin starting Wednesday of next week.           The Qt Installation Help Session will be happening tonight from 7-9pm PDT. The point of this help session is to help those of you that have encountered issues in the installation process. To save time, please make sure you have attempted to work through the installation process before coming to the help session tonight. For those of you that want to attend the session tonight, we will be using Queuestatus to manage requests. You can get in line to get help by signing up for the queue after it opens at 7pm. When signing up, please make sure to have your Zoom app open and to include your SUNetID (the letters in front of your  @stanford.edu email address) when signing up in the queue so that we can initiate a call with you on Zoom.           Assignment 0 is due tomorrow (Friday, April 10) at 11:59pm Anywhere on Earth (reference clock here). Make sure to get Qt Creator installed so that you can complete the assignment and be ready to start on Assignment 1 when that is released over the weekend! We've really enjoyed reading all of the form responses from those of you that have submitted so far - our respondents so far span 22 unique time zones and folks from all different walks of life!           If you have academic accommodations, please email Nick your OAE letter as soon as possible (if you have not already done so), so he can start to make arrangements. If you don't know what that means, don't worry about it!           Office Hours, Getting Help in CS106B, and Zoom Info 1 week and 5 days ago by Nick  With Assignment 0 out and the quarter starting to get into full swing, we will be starting to hold office hours beginning on Wednesday (4/8)! For more information about office hours, check out the Office Hours Schedule, which is also linked under the 'Quick Links' sidebar menu. This page contains information about the scheduling and format of office hours this quarter.  Additionally, there were multiple other avenues for getting help in CS106B that Chris introduced yesterday, including the LaIR, Ed Discussion, and email. For help navigating these different resources, check out the Getting Help page!  Finally, we have collected all the Zoom information for lecture, office hours, section and LaIR, all in one helpful place. You can find all this info on the Zoom Details page. This page has restricted access to enrolled students. If you need to access the page but are not officially enrolled in the class, please email Nick. If you are an auditor or waiting on a petition to officially enroll in the class, you can still access the Zoom webinar links for lecture from the course Canvas page.       Mental Health and Well-Being Resources 2 weeks ago by Nick  Our main priority as a course staff this quarter is your physical and mental health and well-being. While each member of the course staff is here to support you, we are not the only resources that are available to you this quarter. Although the majority of you will not be on campus this quarter, many of the traditional on-campus offices and departments that exist to support students have transitioned to a virtual format for this upcoming quarter. Here is a (non-exhaustive) list of some of the resources that we want you all to be aware of this quarter:          Vaden Health Center will be providing virtual one-on-one Well Being Coaching sessions to help support students in achieving well-being in these challenging times           Your Residence Deans and Graduate Life Office Deans will still be available for urgent/emergency response and consultation           Vaden Health Center is also providing an entire online hub dedicated to virtual well-being resources. Included are well-being tips and a calendar of continuing virtual well-being events.           Stanford Mutual Aid is providing a wide diversity of different resources, from housing to emotional support, all across the world.       We hope that you will take the time this quarter to keep a pulse on your own mental health and well-being and utilize the above resources as necessary to build strength and resiliency in these uncertain times.        Who are you? 2 weeks ago by Nick  Even though CS106B is going to be a large class this quarter, all three of us on the course staff are interested to get to know each and every one of you! To that end, we have released a short Assignment 0, which includes a survey to help us learn more about you, along with a short tutorial to get you familiarized with Qt Creator, the development environment we will be using this quarter. You can find more information about the assignment on the Assign0 webpage.  This survey will help us tailor the class according to your needs and preferences. Please complete the assignment by Friday, April 10th at 11:59pm AoE (Anywhere on Earth).       CS106B ACE 2 weeks ago by Nick  CS100B, also known as CS106B ACE, is a 1-unit supplementary section designed to build a stronger foundation in computer science. Students participating in ACE will attend an additional weekly section and participate in exam review sessions and individual tutoring. Section will take place on Zoom from 4:30-6:30pm PDT every Thursday, starting this week.  ACE is one of the School of Engineering's Equity and Inclusion Initiatives. We especially want to provide an opportunity for students who come from educationally disadvantaged backgrounds or for anyone who feels they might need additional support in order to succeed. We limit enrollment to enable small classes that allow students to have one-on-one interactions with the TA.  If you are interested in joining the ACE section, email Ngoc Tran (Student Services Officer for Equity and Inclusion). If you have any questions about ACE, feel free to reach out to Garrick Fernandez (CS106B ACE TA).       Optional Test Lecture 2 weeks and 3 days ago by Julie, Chris, and Nick  We will be having a test run of our technical setup for delivering lectures this upcoming Friday, April 3 from 9-9:30am PDT. If you want to come by and say hi to the course staff, you can join using this Zoom link. The password for the Webinar is cs106bTest. This is completely optional and no course content will be covered during this lecture. We hope to see you there!       Welcome to CS106B 2 weeks and 6 days ago by Julie, Chris, and Nick  This is the website for CS106B (Programming Abstractions) in Spring 2020.  We're looking forward to a great quarter of online learning with you all! Our first day of class will be April 6, 2020 from 2:30-3:20PM.  This website will be under construction until the first day of class, so please pardon our dust! In the meantime, if you're interested in learning more about the course this quarter, hop on over to the Frequently Asked Questions for answers to questions you may have about CS106B this spring.       Last quarter's website 2 weeks and 6 days ago by Julie, Chris, and Nick  If you are looking for the Winter 2020 CS 106B course website, please click here        "
http://cs106b.stanford.edu/handouts/course_placement.html
"Handout written by Keith Schwarz.  The CS department offers many programming courses and it can be difficult to know exactly where to begin. This handout provides a general overview of these classes and some advice about selecting the class that's right for you.  If you have any questions, please feel free to come talk to the course staff! We'd be happy to offer one-on-one advice.  CS106A: Start here!  CS106A is our first-quarter programming course. If you're interested in learning how to program a computer, this is the place to start. CS106A has no prerequisites - it's open to everyone! Most students interested in learning computer programming will start here, including many eventual CS majors.  CS106A focuses on fundamental concepts in computer programming (expressions, conditionals, loops, methods, arrays, etc.) that arise in many different programming languages. Although CS106A is taught in Python, it is not designed as a class in standard Python programming.  In our experience, we've found that some high school CS classes are more rigorous than others. If you do have high school CS experience, we recommend reviewing the syllabus for CS106A to get a sense of what it covers. If you feel that you've seen all these topics before, you may want to start off in CS106B or CS106X. If you've covered some, but not all, of the topics from CS106A, you might want to look into CS106AX as a starting point. As always, feel free to ask the course staff if you have questions about where to begin!  We recommend that you take CS106A if     You are interested in learning to program computers.   You have little to no prior programming experience.   We recommend that you not take CS106A if     You have prior programming experience at a level comparable to an introductory college course (for example, if you scored a 4 or 5 on the AP CS exam).   You meet the criteria for taking CS106AX and are interested in a more accelerated treatment of the material.   You have prior programming experience and want to learn how to program in Python.   In the 2019-2020 academic year, CS106A is offered every quarter. Visit the CS106A website.  CS106AX: Honors start  If you have some prior programming experience but haven't covered everything that's normally explored in CS106A, then our CS106AX course may be for you. It functions as an introduction to programming in both JavaScript and Python, allowing for a deeper exploration of programming fundamentals than what's typically explored in CS106A. Think of it as a more intensive version of CS106A for folks who have some past experience - it's a great way to learn and solidify the fundamentals for future study, though it's not designed to serve specifically as a deep dive into either JavaScript or Python.  We recommend that you take CS106AX if     You are interested in learning to program computers.   You have some prior programming experience, but not at the level required for CS106B/X.   We recommend that you not take CS106AX if     You have no prior programming experience.   You have sufficient prior programming experience to jump right into CS106B or CS106X (for example, you've scored a 4 or 5 on the AP CS exam).   You are taking it because you'd really like to take CS106A, but have a scheduling conflict that prevents you from doing so. (Please don't do this! This is a very different class than CS106A.)   You have prior programming experience and are specifically interested in learning Python or JavaScript.   In the 2019-2020 academic year, CS106AX is offered in Fall quarter. Visit the CS106AX website.  CS106B: Next step  CS106B is our second course in computer programming. It focuses on techniques for solving more complex problems than those covered in CS106A and for analyzing program efficiency. Specifically, it explores fundamental data types and data structures, recursive problem solving, graph algorithms, and basic algorithmic analysis.  CS106B assumes you have programming experience at the level of CS106A, though you don't necessarily have to have taken CS106A in order to take CS106B. If you've seen basic control structures (conditions, loops), variables, arrays/lists, maps, and program decomposition, then you should be ready to take CS106B.  CS106B is taught using the C++ programming language, but uses C++ more as a vehicle for ideas than as an object of study. If you're interested in studying C++ in depth, consider looking into CS106L.  We recommend that you take CS106B if     You have prior programming experience at the level of CS106A or CS106AX.   You are interested in learning more about problem-solving with computers.   You've programmed before but have not seen recursion, data structures, or algorithmic analysis.   We recommend that you not take CS106B if     You already have completed equivalent coursework elsewhere.   You have little to no prior programming experience.   You have prior programming experience and want to specifically learn C++ programming.   In the 2019-2020 academic year, CS106B is offered every quarter. Visit the CS106B website.  CS106X: Next step, Honors  CS106X is the honors version of CS106B. It covers the same material as CS106B at a slightly faster pace, plus some additional topics not normally covered in CS106B. Depending on the offering, CS106X sometimes has an open-ended final project that culminates in a poster session. In the past, CS106X used to be CS106A and CS106B combined into a single quarter, but that is not currently the case.  You shouldn't feel pressure to take CS106X if you're thinking that at some point you might go on to major in computer science. Most CS majors go through the CS106A/B sequence, with only a small number of students opting to take CS106X. Rather, we'd recommend taking CS106X only if you're really interested in the material and want to explore it in more depth.  We recommend that you take CS106X if     You meet all criteria for taking CS106B.   You want to get a more in-depth treatment of the topics from CS106B.   You are willing to put in more work than is necessary for CS106B.   We recommend that you not take CS106X if     You have no programming experience and are hoping to complete the equivalent of CS106A/B in a single quarter.   You are taking it because you'd really like to take CS106B, but have a scheduling conflict that prevents you from doing so. (Please don't do this! Most people who try going down this route end up in Frown Town.)   You really want to take CS106B, but are concerned that you need to take CS106X to avoid falling behind everyone else (trust us, that's not going to happen.)   In the 2019-2020 academic year, CS106X is offered in Fall quarter. Visit the CS106X website.  CS106L: C++ language  CS106L is a one-unit companion course to CS106B/X that focuses purely on the C++ programming language. Unlike CS106A and CS106B, which focus more on general programming skills and fundamental programming concepts, CS106L is specifically designed to focus on language features particular to C++ and how to use the C++ programming language to solve problems. Although CS106L is designed as a companion course to CS106B and CS106X, it's open to anyone with a comparable background.  We recommend that you take CS106L if     You have prior programming experience at the level of CS106B or CS106X (or are currently enrolled in those courses.)   You are interested in learning more about the C++ programming language.   We recommend that you not take CS106L if     You want a deeper understanding of topics like recursion, data structures, or big-O notation.   You want to learn programming at the level of CS106B or CS106X, but don't have the time to take those courses.   In the 2019-2020 academic year, CS106L is offered year-round. Visit the CS106L website.  CS107: How it all works  After completing the intro programming sequence, CS107 takes you under the hood to learn the ins and outs of computer systems. It explores how high-level programming constructs are represented internally inside the computer and how those internal representations affect program behavior and performance. Along the way, it provides programming maturity and exposure to developing software in a Unix environment.  CS107 has either CS106B or CS106X as prerequisites and assumes an understanding of fundamental programming techniques and good programming style. As a result, it's rare for incoming students to jump directly into CS107 and to skip the CS106 series entirely. Typically, we'd only recommend this to students with a background comparable to CS106A/B and who already have good programming style. Most students, even those who go on to be CS majors, usually begin in CS106A/B/X.  We recommend that you take CS107 if     You have completed CS106B or CS106X or have the equivalent programming background, including familiarity with recursion and fundamental data structures (binary trees, dynamic arrays, linked lists, graphs, etc.)   You have experience writing readable code - writing comments, decomposing problems into smaller pieces, etc.   We recommend that you not take CS107 if     You have never before taken a class in computer programming.   You have prior programming experience, but have not met the postconditions of CS106B/X.   In the 2019-2020 academic year, CS107 is offered every quarter. Visit the CS107 website.  CS107E: How it works, embedded  CS107E is version of CS107 that covers similar topics but which focuses on programming a small computer that can easily fit into the palm of your hand. The class is smaller and more project-oriented than CS107 and lets you play around with small embedded devices to see how low-level systems concepts directly let you control physical devices. The CS107E FAQ offers perspective on advice on choosing between 107 and 107E.  We recommend that you take CS107E if     You meet all the requirements for CS107.   You enjoy working on open-ended projects.   We recommend that you not take CS107E if     You're nervous about taking CS107 and want to satisfy that requirement in a different way.   In the 2019-2020 academic year, CS107E is offered in Winter and Spring quarters. Visit the CS107E website.  CS105: Alternative start  If you're looking to learn more about computers or computing (for example, you want to learn how to make a web page, or how the Internet works, or how a computer is put together) without focusing too much on programming, you may want to try CS105. This course is designed to give a broader introduction to computing than CS106A at the expense of more significant programming depth.  We recommend that you take CS105 if     You have no prior background in computer programming.   You are interested in learning about computers and how programs control computers.   You are interested in exploring programming in less depth than what's covered in CS106A.   We recommend that you not take CS105 if     You know for certain that later on, you'll be taking CS106A.   You have prior programming experience at the level of CS106A or higher.   In the 2019-2020 academic year, CS105 is offered in Fall and Spring quarters.Visit the CS105 website.  CS106E: Alternative next step  CS106E is a terminal course for non-CS majors who have already taken CS106A and want to have a solid understanding of computer technology in addition to the programming the other CS106 courses focus on. The course is particularly useful to anyone that might work in the tech industry in a non-programming capacity. The course covers topics such as how the internet works, what an operating system does, how websites are built, cloud computing, artificial intelligence, computer security, and privacy.  We recommend that you take CS106E if     You meet all the requirements for taking CS106B.   You are fairly certain that you won't be continuing onward to a CS major in the future.   We recommend that you not take CS106E if     You are thinking about majoring in CS, but would like an easier alternative to CS106B/X.   In the 2019-2020 academic year, CS106E is offered in Spring quarter.Visit the CS106E website. "
http://cs106b.stanford.edu/easter_egg
"Here is a hidden file on the course website, buried deep among the many other pages containing important course information. For your entertainment, it also contains an easter egg, which can only be found by using the \"Search\" feature in the top left corner of the website…  A classic XKCD comic that we can all relate to:   "
http://cs106b.stanford.edu/faq
"These questions are meant to provide information about how certain course components will look during the Spring 2020 virtual quarter. We are trying our best as a course staff to be up front and transparent about what CS106B will look in these unprecedented times, course policies may continue to change as the situation evolves. More information about  assignments, section, and assessments can be found under the respective tabs on the navigation bar. Still have unanswered questions? Hop on over to the forum and ask! We're happy to help.  How will lectures be delivered? Where can I access the lectures? As per university policy, all lectures and course content this quarter will be delivered online. We will be hosting all of our lecturers this quarter via Zoom webinars. You can find the Zoom information for each lecture on Canvas, via the course calendar there. More information about lecture can be found on the About Lecture page.  Will the lectures be recorded and available to watch online? Yes, the lecturers will be recorded and made available through Canvas, under the Course Videos tab, shortly after class ends at 3:30pm PDT.  Will there be section this quarter? Is section attendance required? Yes, we will be having weekly discussion sections this quarter, as we normally would have during an on-campus quarter. Attendance and participation in section will be mandatory for all students. Your section leader will be grading your participation in section on a weekly basis, and these grades will make up 10% of your final grade. If you have concerns about your ability to attend and participate in section, due to any factor (time zone, technological barriers, etc.) please email Nick (nbowman@stanford.edu) and he can work with you to arrange necessary accommodations. More information about section can be found on the About Section page.  How will virtual office hours work? How can I get help in this class? There will be multiple ways to get help in CS106B. The main resource for conceptual and debugging help will be the LaIR, which is a help center staffed by section leaders from 5-9pm PDT on Sunday-Thursday nights. Before signing up for the LaIR using the remote signup link, make sure to read the student LaIR guide (Coming Soon!). In addition, each of the course staff (Chris, Julie, and Nick) will have 4 hours of office hours every week. The times of these office hours can be found on the side bar of the main course webpage. Access information for these office hours will be coming soon. Additionally, you can ask questions and receive help asynchronously using the class forum, linked from the main home webpage.  Will there be exams this quarter? We will not have traditional examinations in CS106B this quarter. However, we will still have assessments during the middle of the quarter (around Week 6) and at the end of the quarter (during Week 10). While we are still finalizing the exact format and content of the assessments, they will involve a 30 minute 1-on-1 session with your section leader, where you will have the opportunity to demonstrate your knowledge and receive direct feedback. More information can be found on the About Assessments page.  How will final grades be calculated? Course grades will be calculated using the following component weightings:  Assignments 55% Mid-quarter assessment 15% Final Assessment 20% Section Participation 10%  We will use a Satisfactory / No Credit grading scheme for all students, as per the university directive for all courses during Spring 2020. To earn a course grade of Satisfactory, you must have passing work in each of the components.  What sort of flexibility will be offered given the exceptional circumstances? We as the course staff are here to support you and help you succeed in these unprecedented times. If there are circumstances that arise in your personal situation that impact your ability to complete the work for this class, please contact us and we will do the best we can to help you out.  I am currently unable to enroll on Axess. How can I shop the course in the meantime? Canvas has a new feature that allows students to shop courses and access videos without enrolling on Axess. We have configured the CS106B Canvas to be \"opening for shopping\". Please see the Canvas announcement about course shopping for more information. Note that you must be formally enrolled on Axess to submit work for grading.  Do you allow auditors? Auditors are welcome to attend lecture, access our materials, and complete labs and assignments on their own, but work cannot be handed in. We will not be able to grade work from auditors, nor be able to accommodate them in the lab sections, helper hours or the online forum. To get access to the assignments as an auditor, please contact us to let us know you would like to audit the course.  What is CS100B? CS100B is also known as Pathfinders (or ACE). Pathfinders is a supplementary instruction program that meets for a weekly section and holds Pathfinders-specific review sessions. This program is part of the ACE program, and is in addition to all the normal requirements for CS106B. You will receive an extra unit of course credit for the work you do in this program. "
http://cs106b.stanford.edu/getting_help
"We provide a variety of support resources in CS106B to help you as much as possible with assignment, material, or other questions throughout the quarter. These include: your assigned Section Leader, the LaIR, the CLaIR, Ed, and weekly office hours held by Julie, Chris and Nick. To help you make the most of these resources, we've compiled a list of the kinds of common issues or questions that may come up throughout the quarter, and the best way to get help for each.   ❓I have a conceptual question about the course material:  We love conceptual questions. Conceptual questions are the height of all course queries. It often takes more work to figure out what concept you are confused about, but if you do that extra work, you will learn much more in return. You can ask conceptual questions to any course staff.  Go to the LaIR, stop by any office hours, email your Section Leader or post on Ed!  At the LaIR there is a special sign up for conceptual help called the CLaIR, or \"Conceptual LaIR.\" This is a higher priority queue and you will get a faster response. When getting CLaIR help, section leaders won't look at your code but instead teach you the concepts you need for your homework. Understand concepts before you code! It will make life much more pleasant.   ❓I have a bug in my code, or another question about my code:  We all get stuck when programming. There are times when the best thing to do is to work through the bug yourself - learning by doing is powerful. However, there are also times when an experienced programmer can help get you on the right track. Course staff will help you learn how to narrow down what may be going wrong in your code and how to approach fixing it.  Go to the LaIR or stop by Nick's office hours  Although we generally discourage debugging code asynchronously, we are going to make exceptions given the extraordinary circumstances of this quarter. However, we want to avoid debugging code over email as much as possible. Since Ed gives the ability to run code, we would much prefer to help you debug your code there if you are unable to make it to LaIR or office hours due to timezone issues. Just remember that if you post assignment code on Ed, you must do so in a private post.   ❓I have an administrative question:  Post on Ed if it's not specific to you, or email Nick for private matters.  Importantly, only the Head TA is able to grant extensions beyond the normally established assignment deadlines.   ❓I want to chat about life and programming / I need to restrategize: Anyone on the course staff would appreciate a good conversation about where this crazy world is headed. If you are interested in more specific career advice, ideas on how to restrategize your learning, or just want to talk about life at Stanford, please feel free to join Julie, Chris or Nick's office hours.  We have no expectations for students who come to office hours - it's totally fine to just come with a general sense of confusion or the desire to work and ask us questions whenever you need to. "
http://cs106b.stanford.edu/index.html
"     CS106B Programming Abstractions Spring 2020, Lectures: MWF 2:30pm-3:20pm (Pacific Daylight Time, GMT-7)        Announcements        Section Assignments 4 days ago by Nick  Section assignments have been made. Students who filled out the section signup on time should have received an email with details of their section. If your section time no longer works for you or you were unable to sign up for a section in time, visit the CS198 Website to join a section.  This page will also have a link to a list of all the section times for students wishing to make up a missed section. Note that section participation is required for all enrolled students in CS 106B.       Free Online CTL Tutoring 5 days ago by Nick  We've been asked to share this message on behalf of the Center for Teaching and Learning:     Want to meet with an experienced peer to discuss course concepts, think through a problem set, or prepare for an upcoming exam? CTL offers appointment tutoring for CS 106B, in addition to tutoring for a number of other courses. For more information and to schedule an appointment, visit our tutoring appointments and drop-in schedule page. We also have a variety of remote learning opportunities and academic coaching available to assist with all of your learning needs!        Assignment 1 Released 1 week and 1 day ago by Nick  Assignment 1 has now been released! In this assignment, you will get practice with C++ fundamentals, including functions, return, decomposition, strings, as well as good testing and debugging practices. Check out the assignment page for more info!         See older announcements.     Teaching team                      Lecturer: Chris Gregg ✉️cgregg@stanford.edu                         Lecturer: Julie Zelenski ✉️zelenski@stanford.edu                         Head TA: Nick Bowman ✉️nbowman@stanford.edu          Quick Links  ❓ Getting Help 📅 Office Hours 🕵️‍♀️ LaIR Signup  🎥 Zoom Details  ed    &nbsp;Ed Discussion Forum   Qt   &nbsp;Qt Creator   🐍 Python-to-C++ Guide ⚙️ Blank Qt Project 🇨 C++ Standard Library Documentation 🌲 Stanford Library Documentation 🌎 Spring 2020 Student Map 🎵 Collaborative Class Playlist       Next two weeks             &nbsp;     Mon     Wed     Fri     Section/Assign                                                                                                                           2                            Apr 13         📓Vectors and Grids                                Apr 15         📓Stacks and Queues                                Apr 17         📓Sets and Maps                                                      Section1:       ADTs                    &nbsp;                           Assign1:       Getting Your C++ Legs    due  Apr 17 (AoE)                                                                                                   3                            Apr 20         Big O                                Apr 22         Functional recursion                                Apr 24         Fractals                                               &nbsp;                 &nbsp;                           Assign2:       Fun with Collections    due  Apr 25 (AoE)                                       See schedule for entire quarter.  "
http://cs106b.stanford.edu/handouts/honor_code.html
"Written by Eric Roberts, with modifications by others.  Since 1921, academic conduct for students at Stanford has been governed by the Honor Code, which reads as follows:  THE STANFORD UNIVERSITY HONOR CODE          The Honor Code is an undertaking of the students, individually and collectively:                      that they will not give or receive aid in examinations; that they will not give or receive unpermitted aid in class work, in the preparation of reports, or in any other work that is to be used by the instructor as the basis of grading;                       that they will do their share and take an active part in seeing to it that others as well as themselves uphold the spirit and letter of the Honor Code.                       The faculty on its part manifests its confidence in the honor of its students by refraining from proctoring examinations and from taking unusual and unreasonable precautions to prevent the forms of dishonesty mentioned above. The faculty will also avoid, as far as practicable, academic procedures that create temptations to violate the Honor Code.           While the faculty alone has the right and obligation to set academic requirements, the students and faculty will work together to establish optimal conditions for honorable academic work.      The purpose of this handout is to make our expectations as clear as possible regarding the Honor Code. The basic principle under which we operate is that each of you is expected to submit your own work in this course. In particular, attempting to take credit for someone else's work by turning it in as your own constitutes plagiarism, which is a serious violation of basic academic standards.  Under the Honor Code you are obligated to follow all of the following rules in this course:  Rule 1: You must not look at assignment solutions that are not your own.  It is an act of plagiarism to take work that is copied or derived from the work of others and submit it as your own. For example, using a solution from the Internet, a solution from another student (past or present), a solution taken from an answer set released in past quarters, or some other source, in part or in whole, that is not your own work is a violation of the Honor Code. Many Honor Code infractions we see make use of past solution sets. The best way to steer clear of this possibility is simply to not search for solutions to the assignments. Moreover, looking at someone else's solution in order to determine how to solve the problem yourself is also an infraction of the Honor Code. In essence, you should not be looking at someone else's answers in order to solve the problems in this class. This is not an appropriate way to check your work, get a hint, or see alternative approaches.  Rule 2: You must not share your solutions with other students.  In particular, you should not ask anyone to give you a copy of their answers or, conversely, give your answers to another student who asks you for it. Similarly, you should not discuss your solution strategies to such an extent that you and your collaborators end up turning in the same answers. Moreover, you are expected to take reasonable measures to maintain the privacy of your solutions. For example, you should not leave copies of your work on public computers nor post your solutions on a public website.  Rule 3: You must properly cite any assistance you received.  If you received aid while producing your solution, you must mention who you got help from (if that person is not a TA or the instructor) and what specifically he/she helped you with. A proper citation should specifically identify the source (e.g., person's name, book title, website URL, etc.) and a clear indication of how this assistance influenced your work. For example, you might write Student X mentioned the idea of having the base case be Y and the recursive step work in way Z. If you make use of such assistance without giving proper credit - or, if you provide a misleading or inaccurate statement describing the help you received - you may be guilty of plagiarism.  It is also important to make sure that the assistance you receive consists of general advice that does not cross the boundary into having someone else write the actual solutions or show you their solutions. It is fine to discuss ideas and strategies, but you should be careful to write your solutions on your own, as indicated in Rules 1 and 2.  Rule 4: You may only reuse past work in certain, limited situations.  We tend to reuse assignments from quarter to quarter. Following the general principle that the names affixed to a submission should accurately represent its authorship, you may only resubmit work from prior quarters provided that the exact same set of people who initially turned in the assignment resubmit. This means, in particular, that     if you completed an assignment individually in a previous quarter, you may only resubmit that assignment if you do so individually; and   if you completed an assignment with a partner in a previous quarter, you may only resubmit that assignment if you submit with that exact same partner.   To elaborate on that last point, if you worked with a partner in a previous quarter, you are retaking the course or resolving an incomplete, and your partner is not also retaking the class or resolving an incomplete, you may not resubmit the past work you did on that assignment in any circumstance.  The policies above apply equally to reading, copying, or adapting solutions you submitted in previous quarters. For example, if you submitted an assignment individually in a previous quarter, you should not refer to your submission on that assignment if you are planning on redoing the assignment in a pair. Similarly, if in a previous quarter you worked with a partner who is not retaking the class, you must not reread or copy anything from that previous submission in the course of redoing the assignment.  Note: all submissions are subject to automated plagiarism detection.  Stanford employs powerful automated plagiarism detection tools that compare assignment submissions with other submissions from current and previous quarters. The tools also compare submissions against a wide variety of online solutions. These tools are effective at detecting unusual resemblances in programs, which are then further examined by the course staff. The staff then make the determination as to whether submissions are deemed to be potential infractions of the Honor Code and referred to Stanford's Community Standards office.  "
http://cs106b.stanford.edu/lectures/strings/
" Questions and Answers    Lecture 3: Strings CS 106B: Programming Abstractions Spring 2020, Stanford University Computer Science Department Lecturers: Chris Gregg and Julie Zelenski Reading: Programming Abstractions in C++, Chapters 3 &amp; 4     Slide  2  Announcements    Section signups opened yesterday and will be open until Sunday, April 12 at 5pm PDT. Sign up on the CS198 Website. All listed section times are in PDT.   Lecture Format            We are currently working on finding a way to export the live Q&amp;A logs and post them on the course website.       For in-lecture questions, we want to start incorporating more live questions directly from students! If you want to ask a question, you have two options:                    Raise your virtual hand and we will unmute you and call on you           Type your question in the Q&amp;A window followed with \"(ask live)\" and we can give you a chance to ask your question live                           Assignment 0 is due today, Friday April 10 Anywhere on Earth.   Assignment 1 will be released on Saturday early-afternoon PDT. Keep your eyes on the course website for an announcement once it's released!    Slide  3  Today's Topics    Strings            C++ strings vs C strings       Characters       Member Functions       Stanford Library extensions       char       The &lt;cctype&gt; library             Slide  4  Strings in C++  Not this type of string:   or this one:  #include&lt;string&gt; ... string s = \"hello\";      A string is a sequence of characters, and can be the empty string: \"\"   In C++, a string has \"double quotes\", not single quotes:            \"this is a string\"       'this is not a string'           Strings are similar to Python and Java strings, although the functions have different names and in some cases different behavior.   The biggest difference between a Python or Java string and a C++ string is that C++ strings are mutable (changeable).   The second biggest difference is that in C++, we actually have two types of strings (more on that in a bit)     Slide  5  Strings and Characters  Strings are made up of characters of type char, and the characters of a string can be accessed by the index in the string (this should be familiar): string stanfordTree = \"Fear the Tree\";                  index:         0         1         2         3         4         5         6         7         8         9         10         11         12                   character:         'F'         'e'         'a'         'r'         ' '         't'         'h'         'e'         ' '         'T'         'r'         'e'         'e'        char c1 = stanfordTree[3];    // 'r' char c2 = stanfordTree.at(2); // 'a'           Notice that chars have single quotes and are limited to one ASCII character. A space char is ' ', not '' (in fact, '' is not a valid char at all. It is hard to see on the slide, but there is an actual space character between the single quotes in a valid space char, and there is no space in the not-valid example)           There are two ways to loop through the characters in a string:      for (int i = 0; i &lt; stanfordTree.length(); i++) {     cout &lt;&lt; i &lt;&lt; \" : '\" &lt;&lt; stanfordTree[i] &lt;&lt; \"'\" &lt;&lt; endl; } cout &lt;&lt; endl;  for (char c : stanfordTree) {     cout &lt;&lt; \"'\" &lt;&lt; c &lt;&lt; \"'\" &lt;&lt; endl; } cout &lt;&lt; endl;  Output: 0 : 'F' 1 : 'e' 2 : 'a' 3 : 'r' 4 : ' ' 5 : 't' 6 : 'h' 7 : 'e' 8 : ' ' 9 : 'T' 10 : 'r' 11 : 'e' 12 : 'e'  'F' 'e' 'a' 'r' ' ' 't' 'h' 'e' ' ' 'T' 'r' 'e' 'e'      Slide  6  ASCII           The Caesar Cipher is an encryption formed by shifting letters to the left or right in an alphabet, and re-encoding a phrase with the new letters. For a Caesar Cipher of +3, all 'A's would become 'D's, all 'B's would become 'E's, etc. At the end of the alphabet, the letters wrap, so 'X's become 'A's, 'Y's become 'B's, and 'Z's become 'C's. Julius Caesar himself is said to have used this encryption scheme to discuss battle plans with his generals, and it was (in his time) never decrypted.      Characters have a numerical representation, as shown in the ASCII table above.            cout &lt;&lt; (int) 'A' &lt;&lt; endl; // 65       This means you can perform math on characters, but you need to be careful:         string plainText = \"ATTACK AT DAWN\"; string cipherText = \"\"; int key = 5; // caesar shift by five      // only works for uppercase! for (int i=0;i&lt;(int)plainText.length();i++) {     char plainChar = plainText[i];     char cipherChar;     if (plainChar &gt;= 'A' &amp;&amp; plainChar &lt;= 'Z') {         cipherChar = plainText[i] + key;         if (cipherChar &gt; 'Z') {             cipherChar -= 26; // wrap back around         }     } else {         cipherChar = plainChar;     }     cipherText += cipherChar; } cout &lt;&lt; \"Plain text:  \" &lt;&lt; plainText &lt;&lt; endl; cout &lt;&lt; \"Cipher text: \" &lt;&lt; cipherText &lt;&lt; endl;                   Output:         Plain text:  ATTACK AT DAWN Cipher text: FYYFHP FY IFBS                     Slide  7  The &lt;cctype&gt; library     #include&lt;cctype&gt;   This library provides functions that check a single char for a property (e..g, if it is a digit), or return a char converted in some way (e.g., to uppercase)            isalnum: checks if a character is alphanumeric       isalpha: checks if a character is alphabetic       islower: checks if a character is lowercase       isupper: checks if a character is an uppercase character       isdigit: checks if a character is a digit       isxdigit: checks if a character is a hexadecimal character       iscntrl: checks if a character is a control character       isgraph: checks if a character is a graphical character       isspace: checks if a character is a space character       isblank: checks if a character is a blank character       isprint: checks if a character is a printing character       ispunct: checks if a character is a punctuation character       tolower: converts a character to lowercase       toupper: converts a character to uppercase           Examples:     string mixed = \"ab80c3d27\"; cout &lt;&lt; \"The digits in \" &lt;&lt; mixed &lt;&lt; \": \" &lt;&lt; endl; for (int i = 0; i &lt; mixed.length(); i++) {   if (isdigit(mixed[i])) {       cout &lt;&lt; mixed[i] &lt;&lt; endl;   } } string s = \"my string\"; for (int i = 0; i &lt; s.length(); i++) {   s[i] = toupper(s[i]); } cout &lt;&lt; \"Now \" &lt;&lt; s &lt;&lt; \" is all UPPERCASE.\" &lt;&lt; endl;             Slide  8  String Operators     As in Python and Java, you can concatenate strings using + or +=     string s1 = \"Chris\"; string s2 = s1 + \"Gregg\"; // s2 == ChrisGregg           Like in Python (but unlike) in Java, you can compare strings using relational operators:     string s3 = \"Zebra\"; if ((s1 &lt; s3) &amp;&amp; (s3 != \"Walrus\")) {     cout &lt;&lt; s1 &lt;&lt; \" &lt; \" &lt;&lt; s3 &lt;&lt; endl;     cout &lt;&lt; \"letters earlier in the alphabet are \" &lt;&lt; endl          &lt;&lt; \"less than letters later in the alphabet.\"          &lt;&lt; endl; }  cout &lt;&lt; endl;  s1[0] = tolower(s1[0]); // s1 now == \"chris\" if (s1 &gt; s3) {     cout &lt;&lt; s1 &lt;&lt; \" &gt; \" &lt;&lt; s3 &lt;&lt; endl;     cout &lt;&lt; \"UPPERCASE letters are less than LOWERCASE letters\"          &lt;&lt; endl; }          Output:     Chris &lt; Zebra letters earlier in the alphabet are  less than letters later in the alphabet.  chris &gt; Zebra UPPERCASE letters are less than LOWERCASE letters       Unlike in Python and Java, strings are mutable and can be changed (!):     s3.append(\"Giraffe\"); // s2 is now \"ZebraGiraffe\" s3.erase(4,3); // s2 is now \"Zebrraffe\" (which would be a very cool animal) s3[5] = 'i'; // s2 is now \"Zebrriffe\" s3[9] = 'e'; // BAD!!!1! PROGRAM MAY CRASH! POSSIBLE BUFFER OVERFLOW! NO NO NO!                Unlike in Python and Java, C++ does not bounds check for you! The compiler doesn't check for you, and Qt Creator won't warn you about this. We have entered the scary territory of you must know what you are doing. Buffer overflows are a critical way for viruses and hackers to do their dirty work, and they can also cause hard to track down bugs.      The following functions are part of the string class, and can be useful:            s.append(str): add text to the end of a string       s.compare(str): return -1, 0, or 1 depending on relative ordering       s.erase(index, length)   : delete text from a string starting at given index       s.find(str) s.rfind(str): first or last index where the start of str appears in this string (returns string::npos if not found)       s.insert(index, str): add text into a string at a given index       s.length() or s.size(): number of characters in this string       s.replace(index, len, str): replaces len chars at given index with new text       s.substr(start, length) or s.substr(start): the next length characters beginning at start (inclusive); if length omitted, grabs till end of string             Slide  9  C++ -vs- C strings     C++ has (confusingly) two kinds of strings:            C strings (char arrays), inherited from the C language       C++ strings (string objects), which is part of the standard C++ library.       When possible, declare C++ strings for better usability (you will get plenty of C strings in CS 107!)           Any string literal such as \"hi there\" is a C string.   C strings don't have member functions, and you must manipulate them through regular functions. You also must manage the memory properly - this is SUPER IMPORTANT and involves making sure you have allocated the correct memory - again, this will be covered in detail in CS 107.            E.g., C strings do not have a .length() function (there are no member functions, as C strings are not part of a class.           You can convert between string types:            string(\"text\"); converts C string literal into C++ string       string s = someCStr; converts a C string into a C++ string       string.c_str() returns a C string out of a C++ string             Slide  10  C string issues     Does not compile! C strings can't be concatenated with +     string hiThere = \"hi\" + \"there\";           These three all compile and work properly.     string hiThere = string(\"hi\") + \"there\"; string hello = \"hi\"; hello += \"there\";           Bug: sets n to the memory address of the C string \"42\" (ack!). Qt Creator will produce a warning.     int n = (int) \"42\";           Works - this explicitly converts \"42\" to a C++ string, and then uses the Stanford library, stringToInteger() to convert to an int.     int n = stringToInteger(\"42\");             Slide  11  More C string issues     Both bugs. Produces garbage, not \"hi?\" or \"hi42\" (memory address stuff).     string hiQuestion = \"hi\" + '?'; // C-string + char string hi41 = \"hi\" + 41;  // C-string + int           Does work because of the empty C++ string at the beginning     string okayHighQuestion = string(\"\") + \"hi\" + '?';           Works, because of auto-conversion.     string howdy = \"hi\";  howdy += '?'; // \"hi?\", char '?' is converted to string           Adds character with ASCII value 41, ')', doesn't produce \"hi?41\".     s += 41; // \"hi?)\"           Works, because of conversion from int to string using a function.     s += integerToString(41); // \"hi?41\"             Slide  12  Mystery Function! What is the output?    void mystery(string a, string &amp;b) {     a.erase(0,1);     b += a[0];     b.insert(3, \"FOO\"); }  int main() {     string a = \"Stanford\";     string b = \"Tree\";     mystery(a,b);     cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; endl;     return 0; }  Answer: Stanford TreFOOet    Slide  13  The Stanford String library  #include \"strlib.h\"  These are not string class functions.     endsWith(str, suffix)startsWith(str, prefix): returns true if the given string begins or ends with the given prefix/suffix text   integerToString(int)realToString(double)stringToInteger(str)stringToReal(str): returns a conversion between numbers and strings   equalsIgnoreCase(s1, s2): true if s1 and s2 have same chars, ignoring casing   toLowerCase(str)toUpperCase(str): returns an upper/lowercase version of a string        trim(str): returns string with surrounding whitespace removed      Use as follows (remember, not member functions of the string class!):     if (startsWith(nextString, \"Age: \")) {   name += integerToString(age) + \" years old\"; }             Slide  14  String recap     C++ has both C strings and C++ strings. Both are, under the hood, simply arrays of characters. C++ strings handle details for you automatically, C-strings do not.   C++ strings are much more functional and easier to use   Many times (but not always), C-strings auto-convert to C++ strings when necessary   Characters are single-quoted, single-character ASCII numerical values (be careful when applying arithmetic to them)   C++ strings have many functions you can use, e.g., s.length() and s.compare()   The Stanford library also has some extra string functions, which are not part of the string class, but are helpful     Slide  15  References and Advanced Reading    References (in general, not the C++ references!):            Chapter 3 of Textbook       &lt;cctype&gt; functions       Caesar Cipher           Advanced Reading:            C++ strings vs C strings       String handling in C++       Stackoverflow: Difference between string and char[] types in C++           "
http://cs106b.stanford.edu/section/section1/
"     Our section materials are a joint effort of many lecturers and head TAs over the years.  This week's section exercises explore ADTs: Grids, Vectors, Stacks, Queues, Maps and other compound containers. Additionally, we included some exercises covering material from Week 1 lectures (functions, parameters, return, decomposition, strings). Since section doesn't meet in Week 1, these problems are provided as extra practice on those topics.  Each week, we will also be releasing a Qt Creator project containing starter code and testing infrastructure for that week's section problems. When a problem name is followed by the name of a .cpp file, that means you can practice writing the code for that problem in the named file of the Qt Creator project. Here is the zip of the section starter code:  📦 Starter code 1) Returning and Printing  Topics: Function call and return, return types  Below is a series of four printLyrics_v# functions, each of which has a blank where the return type should be. For each function, determine    what the return type of the function should be,   what value, if any, is returned, and   what output, if any, will be produced if that function is called.   Is it appropriate for each of these functions to be named printLyrics? Why or why not?  _____ printLyrics_v1() {     cout &lt;&lt; \"Havana ooh na na\" &lt;&lt; endl; } _____ printLyrics_v2() {     return \"Havana ooh na na\"; } _____ printLyrics_v3() {     return \"H\"; } _____ printLyrics_v4() {     return 'H'; }      Solution         void printLyrics_v1() {     cout &lt;&lt; \"Havana ooh na na\" &lt;&lt; endl; }  string printLyrics_v2() {     return \"Havana ooh na na\"; }  string printLyrics_v3() {     return \"H\"; }  char printLyrics_v4() {     return 'H'; }          Of these four functions, only printLyrics_v1 will print anything. Specifically, it prints out the string \"Havana ooh na na.\". The name printLyrics is inappropriate for the other functions, as those functions don't actually print anything. 😃      The function printLyrics_v1 doesn't return anything - it just sends information to the console. As a result, its return type should be void. The functions printLyrics_v2 and printLyrics_v3 each return strings, since C++ treats anything in double-quotes as a string. Finally, printLyrics_v4 returns a char, since C++ treats anything in single-quotes as a character.      2) References Available Upon Request Topic: Reference parameters, range-based for loops  Reference parameters are an important part of C++ programming, but can take some getting used to if you're not familiar with them. Trace through the following code. What does it print?  void printVector(const Vector&lt;int&gt;&amp; values) {     for (int elem: values) {         cout &lt;&lt; elem &lt;&lt; \" \";     }     cout &lt;&lt; endl; }  void maui(Vector&lt;int&gt; values) {     for (int i = 0; i &lt; values.size(); i++) {         values[i] = 1258 * values[i] * (values[2] - values[0]);     } }  void moana(Vector&lt;int&gt;&amp; values) {     for (int elem: values) {         elem *= 137;     } }  void heihei(Vector&lt;int&gt;&amp; values) {     for (int&amp; elem: values) {         elem++;     } }  Vector&lt;int&gt; teFiti(const Vector&lt;int&gt;&amp; values) {     Vector&lt;int&gt; result;     for (int elem: values) {         result += (elem * 137);     }     return result; }  int main() {     Vector&lt;int&gt; values = { 1, 3, 7 };     maui(values);     printVector(values);     moana(values);     printVector(values);     heihei(values);     printVector(values);     teFiti(values);     printVector(values);     return 0; }      Solution         Here's the output from the program:     1 3 7 1 3 7 2 4 8 2 4 8          Here's a breakdown of where this comes from:            The maui function takes its argument by value, so it's making changes to a copy of the original vector, not the vector itself. That means that the values are unchanged back in main.       The moana function uses a range-based for loop to access the elements of the vector. This makes a copy of each element of the vector, so the changes made in the loop only change the temporary copy and not the elements of the vector. That makes that the values are unchanged back in main.       heihei, on the other hand, uses int&amp; as its type for the range-based for loop, so in a sense it's really iterating over the elements of the underlying vector. Therefore, its changes stick.       The teFiti function creates and returns a new vector with a bunch of updated values, but the return value isn't captured back in main.           3) SumNumbers (sum.cpp)  Topics: Vectors, strings, file reading  The function sumNumbers reads a text file and sums the numbers found within the text. Here are some library functions that will be useful for this task:     readEntireFile, to read all lines from a file stream into a Vector   stringSplit, to divide a string into tokens   isdigit, to determine whether char is a digit   stringToInteger, to convert a string of digits to integer value   In particular you will be asked to write the following function  int sumNumbers(string filename)  When given the following file, named numbers.txt, as input, your function should return 42. 42 is the Answer to the Ultimate Question of Life, the Universe, and Everything This is a negative number: -9 Welcome to CS106B! I want to own 9 cats.       Solution         bool isNumber(string s) {     // strip negative sign off negative numbers     if (s.length() &gt; 0 &amp;&amp; s[0] == '-'){         s = s.substr(1);     }     for (char ch : s)         if (!isdigit(ch)) return false;     return s.length() &gt; 0; }  int sumNumbers(string filepath) {     ifstream in;     Vector&lt;string&gt; lines;     int sum = 0;      if (!openFile(in, filepath))         return 0;      readEntireFile(in, lines);     for (string line : lines) {         Vector&lt;string&gt; tokens = stringSplit(line, \" \");         for (string t : tokens) {             if (isNumber(t)) {                 sum += stringToInteger(t);             }         }     }     return sum; }          4) Debugging Deduplicating (deduplicate.cpp)  Topics: Vector, strings, debugging  Consider the following incorrect C++ function, which accepts as input a Vector&lt;string&gt; and tries to modify it by removing adjacent duplicate elements:  ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️ void deduplicate(Vector&lt;string&gt; vec) {     for (int i = 0; i &lt; vec.size(); i++) {         if (vec[i] == vec[i + 1]) {              vec.remove(i);         }     } }  ⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️⚠️  The intent behind this function is that we could do something like this: Vector&lt;string&gt; hiddenFigures = {     \"Katherine Johnson\",     \"Katherine Johnson\",     \"Katherine Johnson\",     \"Mary Jackson\",     \"Dorothy Vaughan\",     \"Dorothy Vaughan\" };  deduplicate(hiddenFigures); // hiddenFigures = [\"Katherine Johnson\", \"Mary Jackson\", \"Dorothy Vaughan]  The problem is that the above implementation of deduplicate does not work correctly. In particular, it contains three bugs. Find those bugs, explain what the problems are, then fix those errors.     Solution         There are three errors here:             Calling .remove() on the Vector while iterating over it doesn't work particularly nicely. Specifically, if you remove the element at index i and then increment i in the for loop, you'll skip over the element that shifted into the position you were previously in.       There's an off-by-one error here: when i = vec.size() - 1, the indexing vec[i + 1] reads off the end of the Vector.       The Vector is passed in by value, not by reference, so none of the changes made to it will persist to the caller.           Here's a corrected version of the code:      void deduplicate(Vector&lt;string&gt;&amp; vec) {     for (int i = 0; i &lt; vec.size() - 1; ) {         if (vec[i] == vec[i + 1]) {             vec.remove(i);         } else {             i++;         }     } }           5) Collection Mystery  Topics: Stacks and queues  void collectionMystery(Stack&lt;int&gt;&amp; s)  {      Queue&lt;int&gt; q;     Stack&lt;int&gt; s2;      while (!s.isEmpty()) {        if (s.peek() % 2 == 0) {             q.enqueue(s.pop());          } else {             s2.push(s.pop());         }     }     while (!q.isEmpty()) {         s.push(q.dequeue());      }     while(!s2.isEmpty()) {          s.push(s2.pop());     }     cout&lt;&lt; s &lt;&lt; endl; }  Write the output produced by the above function when passed each of the following stacks. Note that stacks and queues are written in ​front to back order, with the oldest element on the left side of the queue/stack.  Stacks: {1, 2, 3, 4, 5, 6}                ________________________________________ {42, 3, 12, 15, 9, 71, 88}        ________________________________________ {65, 30, 10, 20, 45, 55, 6, 1}    ________________________________________       Solution          {6, 4, 2, 1, 3, 5}  {88, 12, 42, 3, 15, 9, 7}  {6, 20, 10, 30, 65, 45, 55, 1}           6) Mirror (mirror.cpp)  Topic: Grids  Write a function ​mirror​ that accepts a reference to a ​Grid​ of integers as a parameter and flips the grid along its diagonal. You may assume the grid is square; in other words, that it has the same number of rows as columns. For example, the grid below at left would be altered to give it the new grid state at right:  { { 6, 1, 9, 4},                 { {6, -2, 14, 21},   {-2, 5, 8, 12},                  {1, 5, 39, 55},   {14, 39, -6, 18},      =&gt;        {9, 8, -6, 73},   {21, 55, 73, -3} }               {4, 12, 18, -3} }   Bonus: How would you solve this problem if the grid were not square?      Solution         // solution void mirror(Grid&lt;int&gt;&amp; grid) {     for (int r = 0;r &lt; grid.numRows(); r++) {         // start at r+1 rather than 0 to avoid double-swapping          for (int c = r + 1; c &lt; grid.numCols(); c++) {              int temp = grid[r][c];              grid[r][c] = grid[c][r];              grid[c][r] = temp;         }      } } // bonus  void mirror(Grid&lt;int&gt;&amp; grid) {     Grid&lt;int&gt; result(grid.numCols(), grid.numRows());     for (int r = 0; r &lt; grid.numRows(); r++) {         for (int c = 0; c &lt; grid.numCols(); c++) {             result[r][c] = grid[c][r];         }     }     grid = result; }           7) CrossSum (crosssum.cpp)  Topic: Grids  Write a function named crossSum that accepts three parameters - a constant reference to a Grid of integers, and two integers for a row and column - and returns the sum of all numbers in the row/column cross provided. For example, if a grid named g stores the following integers:    col    0  1  2 row  0     { {1, 2, 3},  1       {4, 5, 6},  2       {7, 8, 9} }  Then the call of crossSum(g, 1, 1) should return (4+5+6+2+8) or 25. You may assume that the row and column passed are within the bounds of the grid. Do not modify the grid that is passed in.      Solution          int crossSum(const Grid&lt;int&gt;&amp; grid, int row, int col) {     int sum = 0;     for (int c = 0; c &lt; grid.numCols(); c++) {         sum += grid[row][c];     }     for (int r = 0; r &lt; grid.numRows(); r++) {         sum += grid[r][col];     }     sum -= grid[row][col]; // subtract center because it was added twice     return sum; }           8) Stutter (stutter.cpp)  Topic: Queues  Write a function named ​stutter​ that accepts a reference to a Queue of integers as a parameter and replaces every element with two copies of itself. For example, if  ​q​ stores ​{1, 2, 3}​, the call of ​stutter(q) should change it to store ​{1, 1, 2, 2, 3, 3}​.      Solution         void stutter(Queue&lt;int&gt;&amp; q)  {     int size = q.size();     for (int i = 0; i &lt; size; i++) {         int n = q.dequeue();          q.enqueue(n);          q.enqueue(n);     } }           9) Check Balance (balance.cpp)  Topic: Stacks  Write a function named checkBalance that accepts a string of source code and uses a Stack to check whether the braces/parentheses are balanced. Every ( or { must be closed by a } or ) in the opposite order. Return the index at which an imbalance occurs, or -1 if the string is balanced. If any ( or { are never closed, return the string's length.  Here are some example calls:  //   index    0123456789012345678901234567 checkBalance(\"if (a(4) &gt; 9) { foo(a(2)); }\")  // returns -1 (balanced)  //   index    01234567890123456789012345678901 checkBalance(\"for (i=0;i&lt;a;(3};i++) { foo{); )\") // returns 15 because } is out of order  //   index    0123456789012345678901234 checkBalance(\"while (true) foo(); }{ ()\") // returns 20 because } doesn't match any {  //   index    01234567 checkBalance(\"if (x) {\") // returns 8 because { is never closed      Solution         int checkBalance(string code) {     Stack&lt;char&gt; parens;     for (int i = 0; i &lt; (int) code.length(); i++) {         char c = code[i];         if (c == '(' || c == '{') {         parens.push(c);         } else if (c == ')' || c == '}') {             if (parens.isEmpty()) {                 return i;             }             char top = parens.pop();             if ((top == '(' &amp;&amp; c != ')') || (top == '{' &amp;&amp; c != '}')) {                 return i;             }         }     }      if (parens.isEmpty()) {         return -1; // balanced     } else {         return code.length();     } }           10) Friend List (friendlist.cpp) [Covered Friday]  Topic: Maps  Write a function named friendList that takes in a file name and reads friend relationships from a file and writes them to a Map. friendList should return the populated Map. Friendships are bi-directional, so if Abby is friends with Barney, Barney is friends with Abby. The file contains one friend relationship per line, with names separated by a single space. You do not have to worry about malformed entries.  If an input file named buddies.txt looked like this: Barney Abby Abby Clyde   Then the call of friendList(\"buddies.txt\") should return a resulting map that looks like this:  {\"Abby\":{\"Barney\", \"Clyde\"}, \"Barney\":{\"Abby\"}, \"Clyde\":{\"Abby\"}}  Here is the function prototype you should implement:  Map&lt;string, Vector&lt;string&gt; &gt; friendList(String filename)      Solution         Map&lt;string, Vector&lt;string&gt; &gt; friendList(string filename) {     ifstream in;     Vector&lt;string&gt; lines;      if (openFile(in, filepath)) {         readEntireFile(in, lines);     }      Map&lt;string, Vector&lt;string&gt; &gt; friends;     for (string line: lines) {         Vector&lt;string&gt; people = stringSplit(line, \" \");         string s1 = people[0];         string s2 = people[1];         friends[s1] += s2;         friends[s2] += s1;     }     return friends; }          11) Twice (twice.cpp) [Covered Friday]  Topic: Sets  Write a function named twice that takes a vector of integers and returns a set containing all the numbers in the vector that appear exactly twice.  Example: passing {1, 3, 1, 4, 3, 7, -2, 0, 7, -2, -2, 1} returns {3, 7}.  Bonus: do the same thing, but you are not allowed to declare any kind of data structure other than sets.     Solution         // solution Set&lt;int&gt; twice(Vector&lt;int&gt;&amp; v) {     Map&lt;int, int&gt; counts;     for (int i : v) {         counts[i]++;     }     Set&lt;int&gt; twice;     for (int i : counts) {         if (counts[i] == 2) {             twice += i;         }     }     return twice; }  // bonus Set&lt;int&gt; twice(Vector&lt;int&gt;&amp; v) {     Set&lt;int&gt; once;     Set&lt;int&gt; twice;     Set&lt;int&gt; more;     for (int i : v) {         if (once.contains(i)) {             once.remove(i);             twice.add(i);         } else if (twice.contains(i)) {             twice.remove(i);             more.add(i);         } else if (!more.contains(i)) {             once.add(i);         }     }     return twice; }           "
http://cs106b.stanford.edu/assignments/assign2/
"  This week's lectures have introduced you to the CS106 ADTs and now it's time to put those handy collections to use! With the low-level details abstracted away, your attention is freed to solve  more interesting problems. Your next assignment is to write some client code that heavily leverage the ADTs to do nifty things. The tasks may sound a little daunting at first, but given the power tools in your arsenal, each requires only a page or two of code. Let's hear it for abstraction!  Learning goals    To more fully experience the joy of using pre-written classes.  Most of the heavy-lifting is handled by the collection ADTs.   To stress the notion of abstraction as a mechanism for managing data and providing functionality without revealing the representational details.   To become familiar with using C++ class templates.   To learn how to model and solve problems using classic data structures such as vectors, grids, stacks, queues, sets, and maps.   Assignment parts This assignment consists of a short warmup exercise and then two coding parts, each featuring use of different ADTs. The coding parts are roughly comparable to each other in size and scope, so pace yourself to complete each in about three days.          Warmup     Practice with unit tests and debugging on ADT types.           Maze     A Grid of walls and corridors is used to represent a max and the Stack, Queue, and Set ADTs are used in algorithms that to process and solve a maze.           Search Engine     A Map is used to associate words with a Set of web pages containing that word and allow efficient search for pages matching a compound query.      Getting started  We provide a ZIP of the starter project. Download the zip, extract the files, and open the project in Qt creator.  📦 Starter code  The two source files you will edit are maze.cpp and search.cpp.  Additionally, you will answer some questions in short_answer.txt.  Helpful Resources Here are some resources that you might find helpful while working on the first assignment:    Week 2 Lecture Slides: Monday: Vector/Grid, Wednesday: Stack/Queue, Friday: Set/Map   Getting Help  This assignment is to be completed individually. Working in pairs/groups is not permitted.  As always, feel free to reach out to us if you have questions. Feel free to contact us on Ed, to email your section leader, or to stop by the virtual LaIR (Sunday through Thursday, 5:00PM - 9:00PM PDT or Monday-Friday, 9:00AM - 11:00AM PDT). You can find more information about how to get help at the LaIR here. As a reminder, try to visit the LaIR for coding debugging questions - however if you cannot make the LaIR due to time zone issues, you can post your code on Ed to get help. However, you must use a private post so that you are not posting your code for the whole class to see.  Submit Before you call it done, run through our submission checklist to be sure all your t's are crossed and i's dotted. Then upload your completed files for grading to the Paperless website.  Please submit only the files you edited; for this assignment, these files will be    maze.cpp   search.cpp   short_answer.txt   You don't need to submit any of the other files in the project folder.  🏁 Submit to Paperless  Note: When submitting to Paperless, all due dates and submission times will be displayed in PDT across the website. "
http://cs106b.stanford.edu/assignments/assign0/
"Welcome to CS106B! This assignment is designed to help you get your development environment set up and running so that you can compile, run, and debug programs. There isn't any actual programming involved, and we hope that this doesn't take you too much time to complete. This assignment must be completed individually.  Step 1) Install Qt Creator  Your first task is to configure your computer for Qt Creator, the development environment that we'll be using in CS106B this quarter. Follow the instructions in the Qt Installation Guide for your operating system.  If you run into trouble installing Qt Creator, don't panic! Head TA Nick will be holding a Qt Creator help session virtually on Zoom from 7:00PM - 9:00PM PDT on Thursday, April 9.  Step 2) Download starter project We will configure a starter project with the files needed for each assignment and post it in the form of a ZIP archive. Download the archive and unzip.     📦 Starter code   Step 3) Hash your name  Open the project in Qt Creator and build and run the program. It will ask you to enter your (preferred) first and last names. When you do, it will give back a hash code, a special number associated with your name. You can think of your hash code as a fingerprint associated with your name that's unlikely to be the same as anyone else's fingerprint. Write this number down; you'll need it to complete the assignment!  Step 4) Use the debugger  Open the Assign 0 debugger tutorial. This wonderful guide written by Keith Schwarz walks you through using the debugger on the Name Hash program. Follow along with the step-by-step instructions. At some point, you'll be asked to remember a number. Write this number down; you'll need it to complete the assignment!  Step 5) Read about the Honor Code You are required to read our handout CS106B and the Honor Code before submitting assignments. Do this now before proceeding to the final step.  Step 6) Submit Once you've finished everything, fill out the form at the following URL:    📋 Submit Google form: https://forms.gle/okJNiccWmcTbf5rRA   This form will ask for the numbers from Steps 3 and 4, along with some questions about who you are, why you're awesome, and what your learning environment will look like this quarter. And that's it! You're done! "
http://cs106b.stanford.edu/assignments/assign1/
"Here it is - the first programming assignment of the quarter! This assignment is designed to get you up and running with the C++ language and the tools used in CS106B. The work involves a mix of coding, testing, and debugging tasks. By the end of this assignment, you'll have fully gotten your C++ legs under you! (our apologies for the bad pun…)  The code you will write involves expressions, control structures, functions, string processing, and files. You have prior experience with these concepts, but the tricky part is figuring how to map what you already know to the strange new world of C++. The transition is what this assignment is all about. In addition to giving you practice with C++ syntax and libraries, the assignment will guide you through the tools and approaches you can use to test and debug your code. By the time you've completed it, you'll be a lot more comfortable working in C++ and will be ready to start building larger projects!  This assignment is to be completed individually. Working in pairs/groups is not permitted.  Assignment parts This assignment consists of two parts.          Perfect Numbers     is a fun warmup exercise involving number theory, algorithms, and optimization. It gives you a guided transition into C++, as well as the testing and debugging tools that we will be using in CS106B this quarter.  You can get started on this one right away - and we recommend doing so! Aim to have this part of the assignment completed by Monday, April 13. That way, you'll have time to get cracking on the bigger second part.           Soundex Search     is a complete program that demonstrates a nifty algorithm for matching and grouping names based on their pronunciation. This program uses C++ strings, files, and the Vector class.  Make sure that you have watched the lecture content on strings (Friday and Monday) before starting this part of the assignment.  This part requires you to write a more substantial chunk of code, and getting a jump on it means you will have time to work through issues and reach out for help (using the Ed forum, LaIR, and instructor office hours) if you hit any snags. We recommend starting this part of the assignment no later than Monday, April 13. Aim to have this part of the assignment completed by Friday, April 17.      Getting started  We provide a ZIP of the starter project. Download the zip, extract the files, and open the project in Qt creator.  📦 Starter code  The two source files you will edit are:    perfect.cpp   soundex.cpp   Additionally, you will write short answers to some questions in short_answer.txt.  Helpful Resources Here are some resources that you might find helpful while working on the first assignment:    A Guide to Testing Code in CS106B   A couple of our section leaders have put together a wonderful guide to transitioning from Python to C++ that points out syntactical and functional differences between the two languages.   Week 1 Lecture Slides: Monday, Wednesday, Friday   Getting Help As always, feel free to reach out to us if you have questions. Feel free to contact us on Ed, to email your section leader, or to stop by the virtual LaIR (Sunday through Thursday, 5:00PM - 9:00PM PDT or Monday-Friday, 9:00AM - 11:00AM PDT). You can find more information about how to get help at the LaIR here. As a reminder, try to visit the LaIR for coding debugging questions - however if you cannot make the LaIR due to time zone issues, you can post your code on Ed to get help. However, you must use a private post so that you are not posting your code for the whole class to see.  Submit Before you call it done, run through our submission checklist to be sure all your t's are crossed and i's dotted. Then upload your completed files for grading to the Paperless website.  Please submit only the files you edited; for this assignment, these files will be    perfect.cpp   soundex.cpp   short_answer.txt   You don't need to submit any of the other files in the project folder.  🏁 Submit to Paperless  Note: When submitting to Paperless, all due dates and submission times will be displayed in PDT across the website.  That's it, you're done! Congratulations on finishing your first CS106B assignment! "
http://cs106b.stanford.edu/lectures/vectors-grids/
" Questions and Answers  Lecture 4: The Vector and Grid Classes CS 106B: Programming Abstractions Spring 2020, Stanford University Computer Science Department Lecturers: Chris Gregg and Julie Zelenski     Slide  2  Announcements    Section starts this week! Section assignments will be released on Tuesday (4/14) evening and sections will begin Wednesday (4/15) morning. Reminder: All section times are displayed in PDT.   If you can no longer make the time to which you're assigned (or if you were originally unassigned because you did not submit time preferences), go to this website and you'll be able to switch into any section which still has space.   The (virtual) LaIR is now open - this is a space where you can get live code debugging help from our fleet of awesome section leaders. The LaIR will be open 5pm-9pm PDT Sunday-Thursday and 9am-11am Monday-Friday. This second time is newly added to accommodate those students that are in timezones where the typical LaIR time is inaccessible. Check the Zoom details page for information on how to get help at the LaIR.   Please make your best effort to save code debugging questions for the LaIR or instructor office hours - while we will offer as much flexibility as we can to answer debugging questions on Ed, we only have a limited capacity to do so, and would like to reserve this for folks that are unable to make any of the synchronous help resources that have been offered.     Slide  3  Code Mystery       In the last lecture, we introduced the idea of a C++ reference. What is the output of this code? Fill out the Zoom poll with your answer!   void mystery(int&amp; b, int c, int&amp; a) {      a++;     b--;     c += a;  }  int main() {      int a = 5;      int b = 2;     int c = 8;     mystery(c, a, b);     cout &lt;&lt; a &lt;&lt; \" \" &lt;&lt; b &lt;&lt; \" \" &lt;&lt; c &lt;&lt; endl;     return 0; }  Poll: A. 5 2 8 B. 5 3 7 C. 6 1 8  D. 61 13  E. other     Slide  4  Poll answer: output A. 5 2 8 B. 5 3 7 C. 6 1 8  D. 61 13  E. other  Note: please don't obfuscate your code like this! :(  See the International Obfuscated C Contest for much, much worse examples    Slide  5  A function for Solving the Quadratic Equation      A quadratic equation for variable x is one of the form:  ax2 + bx + c = 0  for some numbers a, b, and c.          The two roots of a quadratic equation can be found using the quadratic formula above.           Example: The roots of x2 - 3x - 4 = 0 are x=4 and x=-1      How would we write a function named quadratic to solve quadratic equations?            What parameters should it accept?       Which parameters should be passed by value, and which by reference?       What, if anything, should it return?           We have choices!     Slide  6  A Function for Solving the Quadratic Equation    /*  * Solves a quadratic equation ax^2 + bx + c = 0,  * storing the results in output parameters root1 and root2.   * Assumes that the given equation has two real roots.  */ void quadratic(double a, double b, double c,                double&amp; root1, double&amp; root2) {     double d = sqrt(b * b - 4 * a * c);     root1 = (-b + d) / (2 * a);     root2 = (-b - d) / (2 * a); }      How are we \"returning\" the results? Answer: by using references to variables   What other choices ccould we have made?     Slide  7  Collections            One of the most powerful aspects of C++ is the ability to have a \"collection\": we will study the six collections shown above.           We will talk about all of these as we go through CS 106B, but you will need to use the Vector and Grid classes for assignment 1.        Slide  8  The Vector Collection     What is a Vector?            It is like a list in Python, or an ArrayList in Java.       It is a list of elements that can grow and shrink.       Each element has a place (or index) in the list.           Important Details            The constructor creates an empty list (more on constructors soon)       The Stanford Vector class performs bounds checks, meaning that if you try to access an element that is outside the bounds of a Vector, the program crashes.       A Vector Knows its size.       To use Vectors, you #include \"vector.h\".           Under the hood, a vector is an array, which means that in the computer's memory, one value follows the next.     Slide  9  Creating a Vector     You must specify the type of your vector (e.g., int, string, etc.)        When a vector is created it is initially empty.      To create a vector called vec that can hold integers (ints), we write the following:     Vector&lt;int&gt; vec;           This calls the default constructor, which just means that it initializes and creates (constructs) an empty vector for us.        Slide  10  Adding elements to a vector     Here is an example where we create a vector called magic and add the numbers 4, 8, 15, and 16 to the vector, and then print out the elment at index 2:     Vector&lt;int&gt; magic; magic.add(4); magic.add(8); magic.add(15); magic.add(16); cout &lt;&lt; magic[2] &lt;&lt; endl;          Output:     15            Notice that the index ordering starts from zero!      In the computer's memory, our vector is represented by one number after another, as follows:     magic:                index:         &nbsp;0&nbsp;         &nbsp;1&nbsp;         &nbsp;2&nbsp;         &nbsp;3&nbsp;                   value:         4         8         15         16          Slide  11  Vectors have useful functions, like size()  magic:                index:         &nbsp;0&nbsp;         &nbsp;1&nbsp;         &nbsp;2&nbsp;         &nbsp;3&nbsp;                   value:         4         8         15         16           The following loops through the values in the vector and prints them:     for(int i = 0; i &lt; magic.size(); i++) {  cout &lt;&lt; magic[i] &lt;&lt; endl; }          Output:     4 8 15 16             Slide  12  A new type of for loop: the for each loop:  magic:                index:         &nbsp;0&nbsp;         &nbsp;1&nbsp;         &nbsp;2&nbsp;         &nbsp;3&nbsp;                   value:         4         8         15         16           The following is a loop that automatically gets the next value in a collection:     for(int value : magic) {  cout &lt;&lt; value &lt;&lt; endl; }          Output:     4 8 15 16             Slide  13  Vector Functions     The following functions are part of the vector collection, and can be useful:            vec.size(): Returns the number of elements in the vector.       isEmpty(): Returns true if the vector is empty, false otherwise.       vec[i]: Selects the ith element of the vector.       vec.add(value): Adds a new element to the end of the vector.       vec.insert(index, value): Inserts the value before the specified index, and moves the values after it up by one index.       vec.remove(index): Removes the element at the specified index, and moves the rest of the elements down by one index.       vec.clear(): Removes all elements from the vector.           For the exhaustive list, check out the Stanford Vector class     Slide  14  The Grid Container      The Grid is a Stanford library class for 2-dimensional arrays, like a matrix in math:                 a0         b0         c0                   a1         b1         c1                   a2         b2         c2          Slide  15  Grid    What is it?            Advanced 2D array.       Think spread sheets, game boards           Important Details            Default constructor makes a grid of size 0       Doesn't support ragged right.       Bounds checks       Knows its size.           We could use a combination of Vectors to simulate a 2D matrix, but a Grid is easier!     Slide  16  Grid Example Code  Grid&lt;int&gt; matrix(2,2);  matrix[0][0] = 42; matrix[0][1] = 6; matrix[1][0] = matrix[0][1]; cout &lt;&lt; matrix.numRows() &lt;&lt; endl; cout &lt;&lt; matrix[0][1] &lt;&lt; endl; cout &lt;&lt; matrix[1][1] &lt;&lt; endl; cout &lt;&lt; matrix[2][3] &lt;&lt; endl;  Let's draw what happens on each line.  Grid&lt;int&gt; matrix(2,2); // Create a 2x2 grid, with 0 as the default entries                         0         1                   0         0         0                   1         0         0        matrix[0][0] = 42; // put 42 at row 0, column 0                         0         1                   0         42         0                   1         0         0        matrix[0][1] = 6; // put 6 at row 0, column 1                         0         1                   0         42         6                   1         0         0        matrix[1][0] = matrix[0][1]; // put the value from r0,c1 at r1,c0                         0         1                   0         42         6                   1         6         0        cout &lt;&lt; matrix.numRows() &lt;&lt; endl; cout &lt;&lt; matrix[0][1] &lt;&lt; endl; cout &lt;&lt; matrix[1][1] &lt;&lt; endl;  Prints the number of rows, then the value at r0,c1, then the value at r1,c1: 2 6 0   cout &lt;&lt; matrix[2][3] &lt;&lt; endl; // attempts to print out the value at r2,c3 *** *** STANFORD C++ LIBRARY  *** An ErrorException occurred during program execution:  *** Grid::operator [][]: (2, 3) is outside of valid range [(0, 0)..(1, 1)] *** libc++abi.dylib: terminate_handler unexpectedly threw an exception 15:25:55: The program has unexpectedly finished. 15:25:55: The process was ended forcefully.  Grids do bounds checking! If you want to bounds check without crashing, you should call the grid.inBounds(row, col) function, which returns true if the row and column are in bounds for the grid.    Slide  17  Grid Functions     The following functions are part of the grid collection, and can be useful:            grid.numRows(): Returns the number of rows in the grid.       grid.numCols(): Returns the number of columns in the grid.       grid[i][j]: selects the element in the ith row and jth column.       grid.resize(rows, cols): Changes the dimensions of the grid and re-initializes all entries to their default values.       grid.inBounds(row, col): Returns true if the specified row, column position is in the grid, false otherwise.           For the exhaustive list, check out the Stanford Grid class     Slide  18  Grid Example: Traversing a Grid  void printGrid(Grid&lt;char&gt; &amp;grid) {     for(int r = 0; r &lt; grid.numRows(); r++) {         for(int c = 0; c &lt; grid.numCols(); c++) {             cout &lt;&lt; grid[r][c];         }         cout &lt;&lt; endl;     } }  If we pass in the following grid, what will print?                         0         1                   0         a         b                   1         c         d                   2         e         f       Output: ab cd ef     Slide  19  Common pitfalls when working with collections in C++     Vector numbers;            Needs a type! Should be: Vector&lt;int&gt; numbers;           void myFunction(Grid&lt;bool&gt; gridParam);            Two issues:                    If you want the original gridParam to be changed in the calling function, you're out of luck.           Inefficient because you have to make a copy of gridParam.                           void printOutGrid(Grid&lt;bool&gt; &amp; grid) {     for(int i = 0; i &lt; grid.numRows(); i++) {         for(int j = 0; j &lt; grid.numCols(); j++) {             cout &lt;&lt; grid[j][i];         }     }     Watch your variable ordering! Better to use r for rows, and c for columns.     Slide  20  Let's Code Instagram!      Slide  21  A color is an int, and and Image is just a Grid&lt;int&gt;!      Slide  22  Let's change the palette of the image      Slide  23  Let's Code!   "
http://cs106b.stanford.edu/lectures/welcome/
" Questions and Answers  Lecture 1: Welcome! CS 106B: Programming Abstractions Spring 2020, Stanford University Computer Science Department Lecturers: Chris Gregg and Julie Zelenski     Slide  2  Lecture 1: It is a Brave New World    Instead of worrying about what you cannot control, shift your energy to what you can create. - Roy T. Bennett, The Light in the Heart      As you know, CS 106B is going to be completely online for the quarter, and all students will receive either an \"S\" (Satisfactory) grade or an \"NC\" (No Credit) grade for the course.   Course lectures will be delivered on Zoom in a \"Webinar\" format, and students who attend live will be able to ask typed questions that will be moderated (likely by a CA or Section Leader) and passed to the instructor. Lectures will also be recorded, and students can watch them at any time during or after lecture delivery.   The course material will closely follow the regular CS 106B curriculum, and post-conditions for the course will be the same as any other quarter - in other words: we are going to do our best to give you an equivalent experience as during a normal quarter, and we hope you will put in the work to learn as much as you can. We will have more logistical details later in this slide deck.     Slide  3  Today's Topics     What day is it? asked Pooh. It's today, squeaked Piglet. My favorite day, said Pooh. - A.A. Milne      Instructor Introductions            What is CS 106B?       Goals for the Course       Components of CS 106B       Assignments, Grading, Due dates, Late days, Sections, Getting Help           C++            Why C++?       Qt Creator       Our first program       Our second program       The importance of Data Structures           Assignment 0     Slide  4  Instruction Team: Lecturers and Head CA     Tell me and I forget, teach me and I may remember, involve me and I learn. - Benjamin Franklin   Lecturers                                                         Chris Gregg               Julie Zelenski           Head CA                                        Nick Bowman             Slide  5  Instruction Team: Section Leaders     When you learn, teach, when you get, give. - Maya Angelou       There will be tons of Section Leaders, who will each lead a small online section, and will grade your work.   They will also hold individual grading sessions (IGs), and they will staff the virtual LaIR for office hours.   SLs are a tremendously dedicated group, and are outstanding teachers in their own right.     Slide  6  What is CS 106B?     Computer Science is no more about computers than astronomy is about telescopes. - Edsger Dijkstra   CS106B: Learn core ideas in how to model and solve complex problems with computers  Complex Problem #1: Self Driving Cars  Source      Slide  7  What is CS 106B?     The most important property of a program is whether it accomplishes the intention of its user.  - C.A.R. Hoare   CS106B: Learn core ideas in how to model and solve complex problems with computers  Complex Problem #2: Compressing Data   Source     Comcast says that I should get \"Upload speeds up to 5 Megabits per second (Mbps)\". If I did (I usually don't), it would be impossible to send uncompressed video to you through Zoom.   Luckily, the H.264 video standard that streaming services like Zoom often use have an incredible 2000:1 compression ratio, meaning that we can accomplish it.   At the end of the course, we will investigate (and you will program!) an encoding  algorithm that produces lossless compression (Zoom is lossy compression, meaning that some data is lost, but hopefully not enough to compromise the viewability of the stream).     Slide  8  What is CS 106B?     Speech recognition and the understanding of language is core to the future of search and information, but there are lots of hard problems such as understanding how a reference works, understanding what 'he', 'she' or 'it' refers to in a sentence. … That's just one of the millions of problems to solve in language. - Ben Gomes, Head of Search at Google   CS106B: Learn core ideas in how to model and solve complex problems with computers  Complex Problem #3: Speech Recognition       The fact that you can ask your phone, in your own language and with your own accent, a question and have it answer within seconds is incredible.   The technology that allows this is not only complex, but it takes a tremendous amount of processing - your voice is analyzed in the cloud, not on your phone.     Slide  9  CS 106B Goals     A goal without a plan is just a wish. - Antoine de Saint-Exupéry      I think goals should never be easy, they should force you to work, even if they are uncomfortable at the time. -Michael Phelps   One of CS 106B's goals: Learn core ideas in how to model and solve complex problems with computers     To that end, we want to:            Explore common abstractions       Harness the power of recursion       Learn and analyze efficient algorithms             Slide  10  Explore Common Abstractions     Abstraction is one of the greatest visionary tools ever invented by human beings to imagine, decipher, and depict the world. - Jerry Saltz      The first programming assignment I had in high school was to find the first 100 Fibonacci numbers. Instead, I thought it would be cooler to write a program to get the teacher's password and all the other students' passwords. And the teacher gave me an A and told the class how smart I was. -Kevin Mitnick   How are user passwords kept secure when logging into a website (or, why shouldn't a website ever be able to send you your password?)      Slide  11  Explore Common Abstractions     The radio doesn't want to play you until you're No.1 on Shazam, and you can't get No.1 on Shazam without getting played. -Tones and I   How does Shazam figure out what song is playing by listening through your microphone?      Slide  12  Explore Common Abstractions     I'm so fast that last night I turned off the light switch in my hotel room and was in bed before the room was dark. -Muhammad Ali   How can it be possible to search for a value in a data structure without having to look at any of the other values (or at least only a few other values)? I.e., how can we program super fast search?   Source    Slide  13  Explore Common Abstractions     The best book on programming for the layman is 'Alice in Wonderland'; but that's because it's the best book on anything for the layman. -Alan Perlis   What is a digital signature, and how can it be used to prove that I was the person that sent an email, or signed a document?   Source    Slide  14  Common Abstractions     The effective exploitation of his powers of abstraction must be regarded as one of the most vital activities of a competent programmer. -Edsger Dijkstra           How are user passwords kept secure when logging into a website (or, why shouldn't a website ever be able to send you your password?)     How does Shazam figure out what song is playing by listening through your microphone?     How can it be possible to search for a value in a data structure without having to look at any of the other values (or at least only a few other values)? I.e., how can we program super fast search?     What is a digital signature, and how can it be used to prove that I was the person that sent an email, or signed a document?         It turns out that all of these are solved with the same abstraction! They all use hashing, which we will talk about near the end of the course.   By learning common abstractions, we can use those abstractions to solve many problems. See the course website to see the list of topics we will cover.     Slide  15  CS 106B Goals  CS106B: Learn core ideas in how to model and solve complex problems with computers     In order to understand recursion you must first understand recursion.  - Unknown      To that end, we want to:            Explore common abstractions       Harness the power of recursion       Learn and analyze efficient algorithms             Slide  16  Harness the power of recursion     When students first encounter recursion, they often react with suspicion to the entire idea, as if they have just been exposed to some conjurer's trick rather than a critically important programming methodology. - Eric S. Roberts      The logic behind the recursive tree below takes about five lines of code:       Slide  17  Harness the power of recursion     Learning to think in this new way requires students to examine recursion from several different perspectives. -Eric Roberts      Recursion is a powerful tool that we will learn — once you start thinking recursively, you will be able to solve many problems that would be extremely hard to solve without it.       Slide  18  CS 106B Goals  CS106B: Learn core ideas in how to model and solve complex problems with computers     I took a computer-science course to fill a prerequisite at Stanford, and I realized that every day was a new problem, and every day you got to think about how to solve something new, how to reason through something new, how to develop an algorithm to solve for something you hadn't worked on before. -Marissa Mayer      To that end, we want to:            Explore common abstractions       Harness the power of recursion       Learn and analyze efficient algorithms             Slide  19  CS 106B: Learn Efficient Algorithms     Efficiency is intelligent laziness. - David Dunham      The following image is from a puzzle game that is part of a potential CS 106B assignment:        Tiles are matched by ensuring that object halves make a pair - so, for instance, a bottle top in red must be next to (or above / below) a bottle bottom in red, as in the second and last tile in the top row.   A puzzle is solved when all tiles match     Slide  20  CS 106B: Learn Efficient Algorithms     I will be ruthless in cutting out waste, streamlining structures and improving efficiency. - Theresa May      The following is the solved puzzle:        Edge-matching games are surprisingly difficult to solve by hand.   Each tile can be oriented four ways, and each tile can be in any of the nine board positions. This gives a total of 9! * 4^9 combinations, or roughly 95 billion different positions.   Knowing what you learned in CS 106A, you could probably write an algorithm that could enumerate all possible combinations, and test each one. If it took one microsecond to check each solution (pretty fast for a desktop computer!), it would take 95,000 seconds to solve the puzzle, or over 26 hours to completely solve the puzzle.   But with the ideas you'll learn in CS 106B, you will be able to write an algorithm to find all correct solutions (and there are eight of them) in a quarter of a second!     Slide  21  CS 106B: Course Information     The Google algorithm was a significant development. I've had thank-you emails from people whose lives have been saved by information on a medical website or who have found the love of their life on a dating website. Tim Berners-Lee - Tim Berners-Lee (inventor of the World Wide Web)      The class website is here: https://web.stanford.edu/class/cs106b/. It will have all announcements, general information, lecture slides, section handouts, and other resources.   We will also be using the Ed Discussion forum this quarter, where you can ask and answer questions about course material (with runnable test code), and also discuss other course-related information.     Slide  22  CS 106B: Course Components     Many jobs at Google require math, computing, and coding skills, so if your good grades truly reflect skills in those areas that you can apply, it would be an advantage. But Google has its eyes on much more. - Thomas Friedman        The mid-quarter and final assessments will be one-on-one with your Section Leader, and will be conducted in a quasi-programming interview. We will have much more detail about those assessments soon.   We want section discussions to be robust, so we are including a section participation component.   The assignments are the most important part of the course, and weighted accordingly.   Important: If you are an undergraduate, you must take the course for 5 units. We will not assign grades to undergraduates who take the course for fewer than 5 units.     Slide  23  CS 106B: Assignments in CS 106B     When I've least expected it, an enormous opportunity or stroke of luck has crossed right under my nose. So I tell everybody, if you're passionate about what you do and you love it, do it. But do your homework. Because you'll never know when the opportunity is going to happen. - Julie Andrews           Due Fridays, Midnight AoE (Anywhere on Earth) (e.g., Baker Island, U.S. Minor Outlying Islands (UTC-12h))           If you hand the assignment in on time, there will be a small bonus applied to your grade. If you hand it in by Sunday, Midnight, AoE, you don't get the bonus. Assignments won't be accepted after Sunday.           Extensions approved by Chris, Julie, or Nick.           Graded by your section leader.           Interactive, one-on-one grading session.           Graded on Style and Functionality. We will give you many exposed functionality tests, but we won't necessarily give you all of them for all assignments.        Slide  24  CS 106B: Grading Style     Style is the substance of the subject called unceasingly to the surface. - Victor Hugo                  Grade               Description                       +               Exceeds requirements.                 &#10003;+               Satisfies all requirements of the assignment.                 &#10003;               Meets most requirements, but with some problems.                 &#10003;-               Has more serious problems.                 -               Better than nothing.             Slide  25  CS 106B: Sections     Poetry comes alive to me through recitation. - Natalie Merchant        Weekly 50-min Zoom section led by awesome section leaders (the backbone of the class!)   Signups begin Thursday at 5:00pm PDT   Signups close Sunday at 5:00pm PDT     Slide  26  You need to ask questions if you are confused     The best scientists and explorers have the attributes of kids! They ask question and have a sense of wonder. They have curiosity. 'Who, what, where, why, when, and how!' They never stop asking questions, and I never stop asking questions, just like a five year old. - Sylvia Earle      Please make judicious use of Ed Discussion, Section, and Office Hours!     Slide  27  Getting Help     I am going to change the world, and I'm talking to everybody in the possible world that I can get to that can help me to do that. - Abby Wambach      Steps to get help in CS 106B:      Ed Discussion   Sign in to the LaIR / Instructor Office Hours   Contact your Section Leader   Email Chris, Julie, or Nick     Slide  28  One Last Detail…     Writing in C or C++ is like running a chain saw with all the safety guards removed. - Bob Gray      Within C++, there is a much smaller and cleaner language struggling to get out. - Bjarne Stroustrup (the creator of C++)      C++: an octopus made by nailing extra legs onto a dog.  - Steve Taylor   C++     Slide  29  C++     Writing in C or C++ is like running a chain saw with all the safety guards removed. - Bob Gray             Although there are hundreds of computer languages, in CS 106B we will be using the C++ language, which is not the easiest language to learn, but it is powerful and popular (and will help you get an internship!)           What is the most used language in programming? (select to show) Profanity!        Slide  30  CS 106/107 languages     If someone claims to have the perfect programming language, he is either a fool or a salesman or both. - Bjarne Stroustrup                    Class                Language                Year Created                       CS 106A               Python               1990                 CS 106AX               Javascript               1995                 CS 106B/X               C++               1983                 CS 107               C               1972!                   Javascript and C++ have their syntax based on C (Python is a bit different)           The languages are different enough that each does take time to learn.        Slide  31  Your First C++ Program!     And programming computers was so fascinating. You create your own little universe, and then it does what you tell it to do. - Vint Cerf (the \"father of the internet\")           As you'll find out, learning a new language when you already know a language is not really that hard, especially for \"imperative\" languages like Java, C++, and C (and Javascript, Python, and Ruby, etc.)           Non-imperative languages —\"functional\" languages — (LISP, Haskell, ML, etc.) take a completely different mentality to learn, and you'll get to those in later CS classes, like Programming Languages.           Let's write our \"Hello, World!\" program in C++.          Slide  32  Your First C++ Program!     There are two ways to write error-free programs; only the third one works. - Alan Perlis      Steps:            Install Qt Creator (see Assignment 0!)       Download the example \"simple-project\": http://web.stanford.edu/class/cs106b/qt/sample-project.zip       Rename the .pro file hello-world.pro       Open the src folder, delete hello.h and rename hello.cpp to hello-world.cpp       Open hello-world.pro       Click \"Configure Project\"       Open Sources-&gt;src-&gt;hello-world.cpp       Delete everything!       Now we're ready to code…             Slide  33  Your First C++ Program!     When someone says: \"I want a programming language in which I need only say what I wish done\", give him a lollipop.  - Alan Perlis   // Our first C++ program!  // headers: #include &lt;iostream&gt; #include \"console.h\" // Stanford library  using namespace std;  // main int main() {     cout &lt;&lt; \"Hello, World!\" &lt;&lt; endl;     return 0; }  Output: Hello, World!           To compile: Select Build-&gt;Build Project \"hello-world\" (or ⌘-B or Alt-B)           To run in \"Debug\" mode: Select Debug-&gt;Start Debugging-&gt;Start Debugging (or ⌘-Y or Alt-Y)           You should see a console window pop up that says, \"Hello, World!\"        Slide  34  Your Second C++ Program!     If people built houses the way we write programs, the first woodpecker would wipe out civilization.  - Dennis Hall           Let's write a more advanced program, one that creates a vector (which is similar to a list in Python), and populates the vector with 100,000 even integers from 0 to 198,998.           You'll see that this looks somewhat different than the equivalent program in Python - ther are a number of differences in  C++.           For time reasons, we'll just write it in the same hello-world.cpp file.          Slide  35  Your Second C++ Program!     Software and cathedrals are much the same - first we build them, then we pray. - Sam Redwine   // Populate a Vector  // headers: #include &lt;iostream&gt; #include \"console.h\" // Stanford library #include \"vector.h\" // Stanford library  using namespace std;  const int NUM_ELEMENTS = 100000;  // main int main() {     Vector&lt;int&gt; myList;     cout &lt;&lt; \"Populating a Vector with even integers less than \"          &lt;&lt; (NUM_ELEMENTS * 2) &lt;&lt; endl;      for (int i=0; i &lt; NUM_ELEMENTS; i++){         myList.add(i*2);     }      for (int i : myList) {         cout &lt;&lt; i &lt;&lt; endl;     }     return 0; }     Slide  36  The Importance of Data Structures     Beware of bugs in the above code; I have only proved it correct, not tried it. - Donald Knuth      One reason we care about data structures is, quite simply, time. Let's say we have a program that does the following (and times the results):            Creates four list-like containers for data.       Adds 100,000 elements to each container - specifically, the even integers between 0 and 198,998 (sound familiar?).       Searches for 100,000 elements (all integers 0-100,000)       Attempts to delete 100,000 elements (integers from 0-100,000)           What are the results?     Slide  37  The Importance of Data Structures     Computer Science is embarrassed by the computer. - Alan Perlis      Results:   Processor: 2.7GHz Intel Core i7 (Macbook Pro), Compiler: clang++   Compile options:     clang++ -Os -std=c++11 -Wall -Wextra ContainerTest.cpp -o ContainerTest           Structure         Overall(s) Unsorted Vector:  1.45973 Linked List:      8.17542 Binary Tree:      0.02734 Hash Table:       0.01316 Sorted Vector:    0.22202      Difference between unsorted vector and hash table: 111x   Difference between linked list and hash table: 621x!   Note: In general, for this test, we used optimized library data structures (from the \"standard template library\") where appropriate. The Stanford libraries are not optimized.   Overall, the Hash Table \"won\" — but (as we shall see!) while this is generally a great data structure, there are trade-offs to using it.     Slide  38  The Importance of Data Structures     On two occasions I have been asked, - \"Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?\" In one case a member of the Upper, and in the other a member of the Lower House put this question. I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question. - Charles Babbage   Structure         Overall(s)    Insert(s)     Search(s)     Delete(s) Unsorted Vector:  1.45973       0.00045       0.92233       0.53694 Linked List:      8.17542       0.00688       5.92075       2.24779 Binary Tree:      0.02734       0.02415       0.00199       0.00120 Hash Table:       0.01316       0.01116       0.00088       0.00112 Sorted Vector:    0.22202       0.14747       0.00206       0.07248      Why are there such  discrepancies??            Some structures carry more information simply because of their design.       Manipulating structures takes time             Slide  39  HW 0     If you lie to the computer, it will get you. - Perry Farrar      HW 0 is a \"get to know the tools\" assignment.            You can find it here.       Installing Qt Creator will take the most time (multiple hours, in some cases).       The rest of the assignment should not take more than half an hour to complete, and it includes setting up Qt Creator, running an example program, learning about the debugger, and filling out a form.           Thursday night there will be a special LaIR to help install tools if necessary.  Due: Friday, April 10th, at Noon AoE  "
http://cs106b.stanford.edu/lectures/sets-maps/
" Questions and Answers  Lecture 6: The Set and Map Classes CS 106B: Programming Abstractions Spring 2020, Stanford University Computer Science Department Lecturers: Chris Gregg and Julie Zelenski     Slide  2  Announcements    Assignment 1 is due tonight, end-of-day Anywhere on Earth. Assignment 2 coming soon!   The recorded section video for this week has been posted on Canvas for anyone that wants extra review on the last week and a half of lecture content.     Slide  3  Sets and Maps     Today we are going to discuss two new collections: sets and maps.   A set is a collection of elements with no duplicates:    A map is a collection of key / value pairs, and the key is useed to find the value. In python, we call this collection a dict.      Slide  4  Sets     A set is a collection of elements with no duplicates. Sets have (at least) the following operations (and they are fast):            add(value): adds a value to a set, and ignores if the set already contains the value       contains(value): returns true if the set contains the value, false otherwise.       remove(value): removes the value from the set. Does nothing if the value is not in the set.       size(): returns the number of elements in the set       isEmpty(): returns true if the set is empty, false otherwise.       Sets have other useful functions, and you should check the documentation to see them.           Sets do not have indexes!       Slide  5  Sets: simple example Set&lt;string&gt; friends; friends.add(\"nick\"); friends.add(\"chris\"); friends.add(\"julie\"); cout &lt;&lt; boolalpha &lt;&lt; friends.contains(\"voldemort\") &lt;&lt;       &lt;&lt; noboolalpha &lt;&lt; endl; for(string person : friends) {     cout &lt;&lt; person &lt;&lt; endl; }  Output: false chris julie nick     Notice - the output from the for loop is alphabetical! Sets keep their values sorted.     Slide  6  Looping over a Set  for(type currElem : set) {     // process elements one at a time }     You can't use an index-based for loop, becuase Sets do not have indexes!     for(int i=0; i &lt; set.size(); i++) {   // does not work, no index!   cout &lt;&lt; set[i]; }                  Slide  7  Types of Sets     There are actually two types of sets in the Stanford library:            Set                    Iteration over the elements is in sorted order           Really fast access times! O(log n) per retrieval - we will learn about this next week!           Sets are implemented using a \"binary search tree\"                       HashSet                    Iteration over the elements is not in a useful order (it is jumbled)           Really, ridiculously fast!           O(1) per retrieval (again, we will learn what this means next time!)                             Slide  8  Set Operands     Sets can be compared, combined, etc.            s1 == s2 true if the sets contain exactly the same elements       s1 != s2 true if the sets don't contain the exact same elements       s1 + s2 returns the union of s1 and s2 (i.e., all elements in both)       s1 * s2 returns the intersection of s1 and s2 (i.e., only the elements in both sets)       s1 - s2 returns the difference of s1 and s2 (the elements in s1 but not in s2)             Slide  9  Counting Unique Words     Let's write a program to count the unique words in a file      Slide  10  Maps     A map is a collection of pairs (k, v), sometimes called key/value pairs, where v can be found quickly if you know k.   Other terms you may hear for a map are dictionary or associative array.   A map is a generalization of an array, where the \"indexes\" don't need to be integers:      Slide  11  Using Maps     A map allows you to get from one half of a pair to the other.            E.g., to store an association from \"Jenny\" to \"867-5309\":         //  key         value m[\"Jenny\"] = \"867-5309\"; // or: m.put(\"Jenny\", \"867-5309\");                       To get Jenny's number:         string ph = m[\"Jenny\"] // or string ph = m.get(\"Jenny\") cout &lt;&lt; ph &lt;&lt; endl;                  Output:         867-5309                     Slide  12  Maps are Everywhere     Wikipedia: the key is the title, the value is the article:       Slide  13  Creating Maps     A Stanford Map requires two parameters: one for keys, one for values:     // maps from string keys to integer values Map&lt;string, int&gt; votes;  // maps from double keys to Vector&lt;int&gt; values Map&lt;string, Vector&lt;string&gt;&gt; friendMap;              Slide  14  Map Functions     The following functions are part of the Map class:            m.clear() : removes all key/value pairs from the map       m.containsKey(key) : returns true if the map contains a value for the given key       m[key]m.get(key) : returns the value mapped to the given key; if key is not in the map, adds it with the default value (e.g., 0 or \"\")       m.isEmpty() : returns true if the map contains no key/value pairs (size 0)       m.keys() : returns a Vector copy of all keys in the map       m[key] = valuem.put(key, value) : adds a mapping from the given key to the given value; if the key already exists, replaces its value with the given one       m.remove(key) : removes any existing mapping for the given key (ignored if the key doesn't exist in the map)       m.size() : returns the number of key/value pairs in the map       m.toString() : returns a string such as \"{a:90, d:60, c:70}\"       m.values() : returns a Vector copy of all the values in the map             Slide  15  Map Example  Map&lt;string, string&gt; wiki;  // adds name / text pair to dataset wiki.put(\"Neopalpa donaldtrumpi\", articleHTML);  // returns corresponding articleHTML cout &lt;&lt; wiki.get(Yosemite National Park);  // removes the article wiki.remove(Britain in the E.U.);          Slide  16  Types of Maps     There are actually two types of maps in the Stanford library:            Map                    Iteration over the elements is in sorted order           Really fast access times! O(log n) per retrieval - we will learn about this next week!           Sets are implemented using a \"binary search tree\"                       HashMap                    Iteration over the elements is not in a useful order (it is jumbled)           Really, ridiculously fast!           O(1) per retrieval (again, we will learn what this means next time!)                             Slide  17  Map Example: Tallying Votes  // tally votes: // (M)ilk, (S)tokes, (R)ogers string allVotes = \"MMMRMSSMSSMMMMMRRMMMMRRRMMM\";  Map&lt;char, int&gt; voteTally; for (char v : allVotes) {     voteTally[v]++; }  // loop over the map for (char initial : voteTally) {     int numVotes = voteTally[initial];     cout &lt;&lt; initial &lt;&lt; \": \" &lt;&lt; numVotes &lt;&lt; \" votes\" &lt;&lt; endl; }     Why does voteTally[v]++; work? It turns out that when you access a Map's value, you get back a reference! Therefore, updating it here allows it to update inside the map. Cool!   It is equivalent to the following:     int&amp; currentTotal = voteTally[v]; currentTotal++; // update inside the map           Notice how we looped over the map - we only get the keys, and have to manually ask for each value from the key.     Slide  18  Tallying Words     Let's write a program to tally how many of each word is in a file    "
http://cs106b.stanford.edu/qt/
"  Students in the CS106B/X courses use Qt Creator to write C++ programs. Qt Creator is an integrated development environment (IDE) with tools to edit, build, run, and debug programs.  Installing Qt Creator Qt Creator is installed on the campus cluster computers. Students may also choose to install Qt Creator on their own computers.  We have prepared installation guides for each operating system, choose the one for your computer. Please follow the instructions carefully and do not skip steps.     Install Qt Creator on Windows   Install Qt Creator on Mac OS X   Install Qt Creator on Linux   After installation, use the check step instructions to build and run our sample project that confirm your Qt Creator is installed properly and works correctly. If you run into problems, check our troubleshooting guide.  Re-installing: If you already have Qt Creator on your computer, ensure it is up-to-date and has the latest bug fixes. To confirm what version you have, look in the Qt Creator menu for \"About Qt Creator\". The latest version is Qt Creator 4.11.2 Based on Qt 5.14.2  Your version number should be equal or greater. If you need to re-install, follow the install steps above, choosing a distinct destination folder for Qt than your existing install. After your new installation is complete, delete the previous Qt folder so you have only one Qt installed on your system to avoid confusion.  Using Qt Creator Here are some guides on using the tools.     Using Qt Creator   Recommended Qt Creator settings   Troubleshooting common Qt Creator problems   Debugger tutorial from Assignment 0   Video: How to make a new blank Qt Creator project (by CS 106B instructor Chris Gregg)   Document currently maintained by Nick Bowman, Julie Zelenski, and Chris Gregg. Revisions also made by Marty Stepp, Chris Gregg, Cynthia Lee, and Keith Schwarz. Thanks to former CS 106 TAs Reid Watson, Jess Fisher, Ashley Taylor, and Danielle Kain for writing and revising our original Qt Creator instructions.  Last updated 2020/04/02 by Nick Bowman. "
http://cs106b.stanford.edu/lectures/c++/
" Questions and Answers  Lecture 2: From Python to C++ CS 106B: Programming Abstractions Spring 2020, Stanford University Computer Science Department Lecturers: Chris Gregg and Julie Zelenski     Announcements    Office Hours            Instructor + head TA office hours begin today (Wednesday 4/8)!       Check out the office hours calendar for times and Zoom details page for Zoom meeting details.                    Julie has her office hours right after class today!                           CS100B ACE            Additional section for students who would benefit from additional support and resources       Thursday nights from 4:30-6:30pm PDT, asynchronous options available as well       1 additional unit       Reach out to Garrick Fernandez (gfaerr@stanford.edu) for more information, spots on the waitlist are still open           Qt Installation Session            Tomorrow night (Thursday 4/9) from 7-9pm       Get help with installing the software that you need to do assignments in this class.       Information on how to sign up and get help will be posted in an announcement on the course website tomorrow.           Section Signups            Everyone in this class (SCPD students included) is required to sign up for a section.       Your assigned section leader will teach your weekly section, and also be responsible for grading all of your assignments and conducting your assessments.       Section signups will open tomorrow (Thursday 4/9) at 5pm PDT and close on Sunday (4/12) at 5pm PDT - it is not first-come first-served but you must submit your preferences at some point during this time span!       Fill out your section preferences on the CS198 website.             Slide  2  A Tour Through C++    Topics for Today:            What are the core differences between Python and C++?                    Comments           #include statements           typed variables           standard output (cout)           Blocks: curly braces           while loops           for loops           scoping           boolean expressions, boolean operators, and the if statement           functions                            The main function               Passing by value and reference                                   header files           we will cover vectors in the next lecture, and strings in the following lecture                             Slide  3  Overview of C++      If you took CS 106A, taught in Python, this lecture is particularly suited to you. If you took CS 106AJ in Javascript, you will see a good bit of new syntax, but it will be more familiar. If you took AP CS in Java, much of this lecture will be familiar, but some parts will still be new.   C++ is a high-performance, robust (and complex) language. It originally began (in 1985 ) as C with Classes. It has been an Object Oriented language from the beginning, and its inventor, Bjarne Stroustrup, chose to base the language on the \"C\" language because it was a fast, widely used language already.   C++ is complex enough that it is very, very hard to completely master it. We will touch on only a small fraction of the language in this course, but if you want to learn more, there are plenty of tutorials and resources.   Unlike Python, C++ does not come with a built-in library of data structures and functionality, and almost all of those features are provided through libraries.            In CS 106B, we rely primarily on the iostream and string libraries (part of the Standard library available with most C++ compilers), and also with the Stanford library, which includes many data structures, and helper functions.       If you go on to program in C++ in the future (e.g., in CS 110, or in an internship), you will need to learn other standard libraries, which sometimes mimic the Stanford library but with mostly minor differences and some major differences.       C++ is a compiled language, as opposed to Python, which is an interpreted language. This means that before running a C++ program, you must first compile it to machine code.             Slide  4  Comments  You might be used to the following types of comments in Python:  Single-line comments: # Python: # A hash comments out the rest of the line myVar = 5 # everything past the hash is a comment   Multi-line comments: # Python: \"\"\" This is a multiline comment, and I end it with three quotes \"\"\"   C++ also has two types of comments:  Single-line comments: // C++: // Two forward slashes comment out the rest of the line int myVar = 5; // everything past the double-slash is a comment   Multi-line comments: // C++: /* This is a multiline comment, and I end it with an asterisk-slash */     Slide  5  #include statements  In Python, you import modules, and the equivalent in C++ is a #include (pound include). There are two different ways to use this statement:  #include &lt;iostream&gt; When using the angle brackets, &lt; and &gt;, this tells the compiler to include libraries that are in pre-defined locations based on the setup for your compiler or IDE (e.g., Qt Creator).  #include \"all-examples.h\" When using double quotes, this tells the compiler to first search in the same directory as the current file. In this case, the .h extension means header file, which we will discuss soon.     #include directives literally tell the compiler to read in and paste code from another file at that particular point in your program.     Slide  6  Typed Variables     As you should know from prior programming classes, all variables have a type associated with them, where the type describes the representation of the variable. For example, a variable may be an integer, or a floating point number, or a string.   In Python, variables have types, but the type is not explicitly written out when defining a variable. E.g.,     # Python: a = 5 # the Python interpreter knows this is an integer a = \"aardvark\" # now the variable is a string!           In C++, all types must be defined when the variable is created, and a variable cannot change its type. For example:     // C++: int a = 5; // a is an integer char b = 'x'; // b is a char (\"character\") float c = 1.42; // c is a floating point number double d = 1.4245593330222211176; // d is a double, a more accurate floating point number string s = \"this is a C++ string\"; float a = 4.2; // ERROR! You cannot redefine a variable to be another type int a = 12; // ERROR! You do not need the type when re-assigning a variable a = 12; // this is okay           By the way:            In C++, all statements must end with a semicolon ;       Indentation is not enforced by the compiler, but Qt Creator should indent properly for you.             Slide  7  Standard Output     Printing to the screen is the most common output in a program. Being able to output to the screen gives your user feedback, and also can be a great way to debug your programs.   In Python, you have the print function:     # Python: num = 42 theAnswer = \"The answer to life, the universe, and everything\" print(\"{} is {}.\".format(theAnswer, num))          Output:     The answer to life, the universe, and everything is 42.       In C++, we have a function called cout that prints, but we use it in a different way:     // C++: int num = 42; string theAnswer = \"The answer to life, the universe, and everything\"; cout &lt;&lt; theAnswer &lt;&lt; \" is \" &lt;&lt; num &lt;&lt; \".\" &lt;&lt; endl;          Output:     The answer to life, the universe, and everything is 42.       You can think of the double-angle brackets, &lt;&lt; as meaning \"send to cout\".   The endl is necessary to put the cursor on a different line. Here is an example with and without the endl:     // C++: cout &lt;&lt; \"This is some text followed by endl.\" &lt;&lt; endl; cout &lt;&lt; \"This is more text.\"; cout &lt;&lt; \"We want to go to the next line here, too\" &lt;&lt; endl; cout &lt;&lt; \"We made it to the next line.\" &lt;&lt; endl;          Output:     This is some text followed by endl. This is more text.We want to go to the next line here, too We made it to the next line.         Slide  8  Blocks: curly braces, while loops     In Python, a block is defined as an indentation level, where whitespace is important. C++ does not have any whitespace restrictions, so blocks are denoted with curly braces, { to begin a block, and } to end a block.   Blocks are used primarily for functions (we will see this shortly), and also for loops.   Let's first look at the while loop. Here is what you might be used to in Python:     # Python: i = 0 while i &lt; 5:   print(i)   i += 1          Output:     0 1 2 3 4       In C++, we also have a while loop, in the following form:     while (expression) {   statement;   statement;   ...  }           As long as expression is true, the loop continues (we will discuss boolean expressions soon).   The parentheses surrounding expression are required.   Example:     // C++: int i = 0; while (i &lt; 5) {   cout &lt;&lt; i &lt;&lt; endl;   i++; }          Output:     0 1 2 3 4       The i++ increments the variable i by 1, and is the reason C++ got its name! (and there is a corresponding decrement operator, --, as in i--).     Slide  9  for loops     If we know ahead of time how many times we want to run a loop, the for loop is often a better choice than a while loop. In Python, for loops are actually a bit more robust than in C++, and they have a different structure. Here is a typical Python for loop:     # Python: for i in range(3):   print(i)          Output:     0 1 2       In C++, for loops have the following form, which may take a bit of getting used to:     for (initializationStatement; testExpression; updateStatement) {   statement;   statement;   ... }             The initializationStatement happens at the beginning of the loop, and initializes a variable. E.g., int i = 0.   The testExpression is evaluated initially, and after each run through the loop, and if it is true, the loop continues for another iteration. E.g., i &lt; 3.   The updateStatement happens after each loop, but before testExpression is evaluated. E.g., i++.   Here is the above example, written in C++:     // C++ for (int i = 0; i &lt; 3; i++) {   cout &lt;&lt; i &lt;&lt; endl; }          Output:     0 1 2       Here is the equivalent way to write the above code as a while loop:     // C++: int i = 0; while (i &lt; 3) {   cout &lt;&lt; i &lt;&lt; endl;   i++; }           There is another type of for statement that we will cover when we reach collections (e.g., the vector class), so stay tuned!     Slide  10  Scoping    Variables in C++ are scoped to the block they belong in. In other words, a variable is not accessible outside of the block where it is defined. This is also true for the initialization statement in a for loop - if you define a variable there, it is not accessible outside the loop.   Example:     // C++: int main() {   int outsideVar = 5;   for (int loopVar = 0; loopVar &lt; 3; loopVar++) {       int insideVar = 10 * outsideVar;       cout &lt;&lt; outsideVar &lt;&lt; \", \" &lt;&lt; insideVar &lt;&lt; endl;       outsideVar += 2;   }   cout &lt;&lt; outsideVar &lt;&lt; endl; // okay   cout &lt;&lt; insideVar &lt;&lt; endl; // error! insideVar not in scope   cout &lt;&lt; loopVar &lt;&lt; endl; // error! loopVar not in scope   return 0; }          Output (with the last two cout statements removed):     5, 50  7, 70  9, 90  11         Slide  11  Boolean expressions, boolean operators, and the if statement     As in virtually all other programming languages, C++ has boolean expressions and boolean operators, as shown in the following tables:                  Expression               Meaning                       a &lt; b               a is less than b                 a &lt;= b               a is less than or equal to b                 a &gt; b               a is greater than b                 a &gt;= b               a is greater than or equal to b                 a == b               a is equal to b                 a != b               a is not equal to b                          Operator(preferred)               Alternative               Meaning                       a &amp;&amp; b               a and b               Both a AND b are true                 a || b               a or b               Either a OR b are true                 !a               not a               If a is true, returns false, and vice-versa                   The \"preferred\" operators from the second table above are the standard C boolean operators.      The C++ if statement tests a boolean expression and runs a block of code if the expression is true, and, optionally, runs a different block of code if the expression is false. The if statement has the following format:     if (expression) {   statements if true } else {   statements if false }           The parentheses around expression are required.   Additional if statements can be used to check for different conditions, as well:     if (expression1) {   statements if expression1 is true } else if (expression2) {   statements if expression2 is true } else {   statements if neither expression1 nor expression2 is true }           Example code: // C++: int firstNum = 1; string compareText;  for (int secondNum = 0; secondNum &lt; 3; secondNum++) {     if (firstNum &lt; secondNum) {         compareText = \"less than\";     } else if (firstNum &gt; secondNum) {         compareText = \"greater than\";     } else {         compareText = \"equal to\";     }     cout &lt;&lt; \"firstNum is \" &lt;&lt; firstNum &lt;&lt; \", secondNum is \" &lt;&lt; secondNum &lt;&lt; endl;     cout &lt;&lt; \"firstNum is \" &lt;&lt; compareText &lt;&lt; \" secondNum\" &lt;&lt; endl &lt;&lt; endl; }  Output: firstNum is 1, secondNum is 0 firstNum is greater than secondNum  firstNum is 1, secondNum is 1 firstNum is equal to secondNum  firstNum is 1, secondNum is 2 firstNum is less than secondNum   Example code: int x = 5; int y = 7;  if (x == 5 &amp;&amp; y == 7) {     cout &lt;&lt; \"x equals 5 and y equals 7\" &lt;&lt; endl; }  if (x == 5 || y == 5) { // note: cannot combine as if (x || y == 5)     cout &lt;&lt; \"x equals 5 or y equals 5\" &lt;&lt; endl; }  if (x != 5 &amp;&amp; y != 5) {     cout &lt;&lt; \"x is not equal to 5 and y is not equal to 5\" &lt;&lt; endl; } else if (x != 5 || y != 5) {     cout &lt;&lt; \"x is not equal to 5 or y is not equal to 5\" &lt;&lt; endl; }  if (!(x == 5 &amp;&amp; y == 5)) {     cout &lt;&lt; \"not (x is equal to 5 and y is equal to 5) (DeMorgan's Law)\" &lt;&lt; endl; }   Output: x equals 5 and y equals 7 x equals 5 or y equals 5 x is not equal to 5 or y is not equal to 5 not (x is equal to 5 and y is equal to 5) (DeMorgan's Law)    Slide  12  Functions     Much like in Python, Java, Javascript, etc., C++ has functions that you can call (e.g., from a library), and that you can create yourself.   Functions can also return a single value, however we will see how we can utilize reference parameters to share data between functions.   In C++, functions must be declared before they are used. Functions are declared as follows:     returnType functionName(varType parameter1, varType parameter2, ...);                A function can be declared and defined (i.e., have the code, as well) at the same time, but again, only if done before use in another function later in the program.      The first function that runs in any program is the main function, declared as follows:     int main() {   statement   statement   ... }           Before we start declaring other functions besides main, let's use one. The C++ &lt;cmath&gt; library has many mathematical functions. E.g., the square root function, sqrt:   // C++: #include &lt;cmath&gt; #include &lt;iostream&gt;  using namespace std;  int main() {     double fpNum = 1234; // a floating point number      double result = sqrt(fpNum); // set result to be equal to the return value of the sqrt function      cout &lt;&lt; \"fpNum: \" &lt;&lt; fpNum &lt;&lt; endl;     cout &lt;&lt; \"square root of fpNum: \" &lt;&lt; result &lt;&lt; endl;     return 0; // the return value for main must be an integer.               // In main(), a return value of 0 means \"everything worked out\" }   Output: fpNum: 1234 square root of fpNum: 35.1283      Let's write a function of our own, that computes and returns the factorial of a number:   int factorial(int number) {     int result = 1;     for (int n = number; n &gt; 1; n--) {         result *= n;     }     return result;  }           The function above requires that we pass it an integer, and it guarantees that it will return an integer.      You might ask, What if I don't want to return anything from my function? and C++ answers that with the void keyword, which means, the function does not return a type. E.g.,     void printTenTimes(char c) {   for (int i = 0; i &lt; 10; i++) {       cout &lt;&lt; c;   }   cout &lt;&lt; endl; }          This function can be called, but won't return a value:     printTenTimes('c');          Output:     cccccccccc       If we try to get a return value from a void function, the compiler produces an error:       int someResult = printTenTimes('c');          Compiler output:     my-file.cc:32:9: error: cannot initialize a variable of type 'int' with an rvalue of     type 'void'   int someResult = printTenTimes('c');       ^             ~~~~~~~~~~~~~~~~~~ 1 error generated.       One thing you may have to get used to is arcane C++ error messages! The above error message means that we tried to give an integer a value with a type of void, and the compiler won't let us do that.     Slide  13  Passing values to functions by value or reference     Let's jump back to Python for a moment, for those of you who took CS 106A in Python. What is the output of the following program?   # Python: def doubleValue(x):     x *= 2     return x  if __name__ == \"__main__\":     myValue = 5     doubleResult = doubleValue(myValue)      print(myValue)     print(doubleResult)  Output (highlight to reveal): 5 10     The reason for the output is that the parameter x was passed to the doubleValue function by value, meaning that the variable x is a copy of the variable passed in. Changing it inside the function does not change the value in the calling function.        You can modify the contents of objects (such as a list) by passing in the list, but that does not work for regular values.      When passing arguments as parameters to a function in C++ the way we have already seen, we have the same behavior:   // C++: #include&lt;iostream&gt; using namespace std;  int doubleValue(int x) {     x *= 2;     return x; }  int main() {     int myValue = 5;     int result = doubleValue(myValue);      cout &lt;&lt; myValue &lt;&lt; endl;     cout &lt;&lt; result &lt;&lt; endl; }  Output: 5 10     In this case, the parameter x was passed by value.   C++ has a completely different way of passing in arguments as parameters to a function, called pass by reference. To pass a value by reference, the parameter has the ampersand (&amp;) symbol before the variable name, e.g.,     void doubleValueWithRef(int &amp;x);                Now, we have provided the doubleValueWithRef function with a reference to the variable x, which means that if the function modifies x, it is actually modifying the original value - it has a reference to x, or it refers to it.      Let's see how this might work, without needing to return a value from doubleValueWithRef:   #include&lt;iostream&gt; using namespace std;  void doubleValueWithRef(int &amp;x) {     x *= 2; }  int main() {     int myValue = 5;     // int result = doubleValueWithRef(myValue); // Error! the function does not return a value now.     doubleValue(myValue);      cout &lt;&lt; myValue &lt;&lt; endl; }  Output: 10     In this case, myValue was changed by the function, and we did not need a return value.   With references, C++ lets you modify data directly, without copying the data. This is powerful, but as Uncle Ben (in Spiderman) says, With great power comes great responsibility. If you pass a value by reference, you need to understand that the function can modify it directly. We will discuss ways of making this a bit safer in later lectures, but for now know that you need to be somewhat careful and you need to understand it thoroughly.   Passing by reference is most-often used when we want access to the contents of data structures without passing all of the values (which can take time). We will see this when we cover vectors in the next lecture.   One caveat: in order to pass a variable by reference, you need to actually have a variable. The following does not work, for our example above:       doubleValueWithRef(15); // error! cannot pass a literal value by reference          Compiler error:     ../all-examples.cpp:135:5: error: no matching function for call to 'doubleValueWithRef'   doubleValueWithRef(15);   ^~~~~~~~~~~~~~~~~~ ../all-examples.cpp:11:6: note: candidate function not viable: expects an l-value for 1st argument void doubleValueWithRef(int &amp;x);    ^ 1 error generated.         Slide  14  Header files      As C++ has its roots in the C language, it uses C-style header files. A header file generally serves to define functions, classes, and structs (defined later in the course) that will be used by various parts of your program.   C++ programs often have multiple code files, and if two different C++ files (which have the extension .cpp or .cc) use the same functions, they may be defined in a header so that each of the .cpp files knows about the functions.   Header files can also make the compilation steps of a large program faster, which is part of the original reason they were used in C.   Header files should have the .h extension (or, less often, .hpp).   It may be the case that a header file is included in a cascading set of files - one header may include another header, and then a .cpp file might include both headers. As this could cause certain objects to be defined twice, we use a special directive inside header files to limit this:            #pragma once       This means that the compiler will only include the file once during compilation.       Example header file, and corresponding C++ file:           Header: // all-examples.h #pragma once  int square(int x); bool even(int value);   C++ file: // all-examples.cpp #include &lt;iostream&gt; #include \"all-examples.h\"  // we can call the functions before the appear in this file, because they've // already been defined in the header file and we've #included it. int main() {     cout &lt;&lt; square(15) &lt;&lt; endl;     if (even(42)) {         cout &lt;&lt; \"even\" &lt;&lt; endl;     } else {         cout &lt;&lt; \"odd\" &lt;&lt; endl;     } }  int square(int x) {     return x * x; }  bool even(int v) {     return v % 2 == 0; }  Output: 225 even  "
http://cs106b.stanford.edu/lectures/stacks-queues/
" Questions and Answers  Stacks and Queues CS 106B: Programming Abstractions Spring 2020, Stanford University Computer Science Department Lecturers: Chris Gregg and Julie Zelenski     Announcements     Section starts this week! Section assignments were released yesterday, please check your email for your time assignment and Zoom information.   If you have not yet signed up for a section, or you can no longer make your assigned section time, you can go to the CS198 Website and add yourself to any section that has an open spot. If you can't make any of the remaining section times, reach out to Nick.   There will be a recorded video of section problems released on Canvas at the end of every week - this is meant to supplement your experience in section, not replace it.   Assignment 1 is due on Friday! Assignment 2 will be released shortly after.   Note on Ed usage: please reserve assignment code debugging questions for the LaIR or for instructor office hours. We have office hours coverage at many different points in the day throughout the week, and this environment is much more conducive to getting successful debugging help.     Slide  2  Abstract Data Types     We are about to discuss two new containers in which to store our data: the stack and queue containers. These are also known as abstract data types, meaning that we are defining the interface for a container, and how it is actually implemented under the hood is not of our concern (at this point!)   An abstract data type is defined by its behavior from the point of view of the user of the data, and by the operations it can accomplish with the data.   The stack and queue containers have similar interfaces, but they are used for very different problems, as we shall see.     Slide  3  Stacks  A stack is an abstract data type with the following behaviors / functions:     push(value) (or add(value)) - place an entity onto the top of the stack   pop() (or remove()) - remove an entity from the top of the stack and return it   top() (or peek()) - look at the entity at the top of the stack, but don't remove it   isEmpty() - a boolean value, true if the stack is empty, false if it has at least one element. (note: a runtime error occurs if a pop() or top() operation is attempted on an empty stack.)   Why do we call it a stack? Because we model it using a stack of things:       The push, pop, and top operations are the only operations allowed by the stack ADT, and as such, only the top element is accessible. Therefore, a stack is a Last-In-First-Out (LIFO) structure: the last item in is the first one out of a stack.     Slide  4  Stacks    Despite the stack's limitations (and indeed, because of them), the stack is a very frequently used ADT. In fact, most computer architectures implement a stack at the very core of their instruction sets - both push and pop are assembly code instructions.   Stack operations are so useful that there is a stack built in to every program running on your PC — the stack is a memory block that gets used to store the state of memory when a function is called, and to restore it when a function returns.   Why are stacks used when functions are called?            Let's say we had a program like this:        main calls function1, which calls function2, which calls function3.       First, function3 returns, then function2 returns, then function1 returns, then main returns.       This is a LIFO pattern!              Slide  5  Stacks: Tradeoffs     What re some downsides to using a stack?            No random access. You get the top, or nothing.       No walking through the stack at all — you can only reach an element by popping all the elements higher up off first       No searching through a stack.           What are some benefits to using a stack?            Useful for lots of problems - many real-world problems can be solved with a Last-In-First-Out model (we'll see one in a minute)       Very easy to build one from an array such that access is guaranteed to be fast.       Where would you have the top of the stack if you built one using a Vector? Why would that be fast?             Slide  6  Reversing the words in a sentence     Let's build a program from scratch that reverses the words in a sentence.            Goal: reverse the words in a sentence that has no punctuation other than letters and spaces.       How might we do this?              Use a stack   Read characters in a string and place them in a new word.   When we get to a space, push that word onto the stack, and reset the word to be empty.   Repeat until we have put all the words into the stack.   Pop the words from the stack one at a time and print them out.     Slide  7  Reversing the words in a sentence with a stack #include &lt;iostream&gt; #include \"console.h\" #include \"stack.h\"  using namespace std; const char SPACE = ' ';  int main() {     string sentence = \"hope is what defines humanity\";     string word;     Stack&lt;string&gt; wordStack;      cout &lt;&lt; \"Original sentence: \" &lt;&lt; sentence &lt;&lt; endl;      for (char c : sentence) {        if (c == SPACE) {            wordStack.push(word);            word = \"\"; // reset        } else {            word += c;        }     }     if (word != \"\") {         wordStack.push(word);     }      cout &lt;&lt; \"     New sentence: \";     while (!wordStack.isEmpty()) {         word = wordStack.pop();         cout &lt;&lt; word &lt;&lt; SPACE;     }     cout &lt;&lt; endl;      return 0; }  Output: Original sentence: hope is what defines humanity      New sentence: humanity defines what is hope      Slide  8  Next…      Slide  9  Queues     The next ADT we are going to talk about is a queue. A queue is similar to a stack, except that (much like a real queue/line), it follows a \"First-In-First-Out\" (FIFO) model:        The first person in line is the first person served.   The last person in line is the last person served.   Insertion into a queue enqueue() is done at the back of the queue, and removal from a queue dequeue() is done at the front of the queue.     Slide  10  Queues     Like the stack, the queue Abstract Data Type can be implemented in many ways (we will talk about some later!). A queue must implement at least the following functions:            enqueue(value) (or add(value)) - place an entity onto the back of the queue       dequeue() (or remove()) - remove an entity from the front of the queue and return it       front() (or peek()) - look at the entity at the front of the queue, but don't remove it       isEmpty() - a boolean value, true if the queue is empty, false if it has at least one element. (note: a runtime error occurs if a dequeue() or front() operation is attempted on an empty queue).                Please look at the Stanford Library Queue reference for other functions (e.g., there is a back() function that is analogous to front() for the back of the queue - but no removing the value!)      Example     Queue&lt;int&gt; q;                // {}, empty queue q.enqueue(42);               // {42} q.enqueue(-3);               // {42, -3} q.enqueue(17);               // {42, -3, 17} cout &lt;&lt; q.dequeue() &lt;&lt; endl; // 42 (q is {-3, 17}) cout &lt;&lt; q.front() &lt;&lt; endl;   // -3 (q is {-3, 17}) cout &lt;&lt; q.dequeue() &lt;&lt; endl; // -3 (q is {17})             Slide  11  Queue Examples     There are many real world problems that are modeled well with a queue:            Jobs submitted to a printer go into a queue (although they can be deleted, so it breaks the model a bit)       Ticket counters, supermarkets, etc.       File server - files are doled out on a first-come-first served basis       Call centers (your call will be handled by the next available agent)       The LaIR is a queue!       Chris G's research! Scheduling work between a CPU and a GPU is queue based. Actual slide from Chris's Ph.D. dissertation defense:              Slide  12  Queue Mystery            Both the Stanford Stack and Queue classes have a size() function that returns the number of elements in the object.      What is the output of the following code?      Queue&lt;int&gt; queue;  // produce: {1, 2, 3, 4, 5, 6}  for (int i = 1; i &lt;= 6; i++) {      queue.enqueue(i);  }  for (int i = 0; i &lt; queue.size(); i++) {      cout &lt;&lt; queue.dequeue() &lt;&lt; \" \";  }  cout &lt;&lt; queue.toString() &lt;&lt; \"  size \" &lt;&lt; queue.size() &lt;&lt; endl;          A. 1 2 3 4 5 6 {} size 0 B. 1 2 3 {4,5,6} size 3 C. 1 2 3 4 5 6 {1,2,3,4,5,6} size 6  D. none of the above      Answer:     B. 1 2 3 {4,5,6} size 3      Reason: watch out! queue.size() changes while the loop runs! You have to be careful when looping and also checking the size of your container.     Slide  13  Queue Idiom 1     If you are going to empty a stack or queue, a very good programming idiom is the following:     Queue&lt;int&gt; queueIdiom1; // produce: {1, 2, 3, 4, 5, 6} for (int i = 1; i &lt;= 6; i++) {   queueIdiom1.enqueue(i); } while (!queueIdiom1.isEmpty()) {   cout &lt;&lt; queueIdiom1.dequeue() &lt;&lt; \" \"; } cout &lt;&lt; queueIdiom1.toString()    &lt;&lt; \"  size \" &lt;&lt; queueIdiom1.size() &lt;&lt; endl;          Output:     1 2 3 4 5 6 { } size 0         Slide  14  Queue Idiom 2     If you are going to go through a stack or queue once for the original values, a very good programming idiom is the following, which calculates the size of the queue only once:       Queue&lt;int&gt; queueIdiom2;   for (int i = 0; i &lt; 6; i++) {       queueIdiom2.enqueue(i + 1);   }    int origQSize = queueIdiom2.size();   for (int i=0; i &lt; origQSize; i++) {      int value = queueIdiom2.dequeue();      cout &lt;&lt; value &lt;&lt; \" \";      // re-enqueue even values      if (value % 2 == 0) {         queueIdiom2.enqueue(value);      }   }   cout &lt;&lt; endl;   cout &lt;&lt; queueIdiom2 &lt;&lt; endl;          Output:     1 2 3 4 5 6 {2, 4, 6}       There will still be three values left in the queue (2, 4, 6), but we only looped through the queue for the original values.     Slide  15  More advanced stack example            When you were first learning algebraic expressions, your teacher probably gave you a problem like this, and said, \"What is the result?\" 5 * 4 - 8 / 2 + 9      The class got all sorts of different answers, because no one knew the order of operations yet (the correct answer is 25, by the way). Parenthesis become necessary as well (e.g., 10 / (8-3)).   This is a somewhat annoying problem — it would be nice if there were a better way to do arithmetic so we didn't have to worry about order of operations and parenthesis.   As it turns out, there is a \"better\" way! We can use a system of arithmetic called \"postfix\" notation — the expression above would become the following: 5 4 * 8 2 / - 9 +   Wat?     Slide  16  Postfix Example 5 4 * 8 2 / - 9 +          Postfix notation* works like this: Operands (the numbers) come first, followed by an operator (+, -, *, /, etc.). When an operator is read in, it uses the previous operands to perform the calculation, depending on how many are needed (most of the time it is two).           So, to multiply 5 and 4 in postfix, the postfix is 5 4 * To divide 8 by 2, it is 8 2 /           There is a simple and clever method using a stack to perform arithmetic on a postfix expression:            Read the input and push numbers onto a stack until you reach an operator.       When you see an operator, apply the operator to the two numbers that are popped from the stack.       Push the resulting value back onto the stack.       When the input is complete, the value left on the stack is the result.           *Postfix notation is also called \"Reverse Polish Notation\" (RPN) because in the 1920s a Polish logician named Jan Łukasiewicz invented \"prefix\" notation, and postfix is the opposite of postfix, and therefore so-called \"Reverse Polish Notation\"    Slide  17  Postfix Example Code // Postfix arithmetic, implementing +, -, *, /  #include &lt;iostream&gt; #include \"console.h\" #include \"simpio.h\" #include \"stack.h\"  using namespace std;  const string OPERATORS = \"+-*x/\"; const string SEPARATOR = \" \";  // function prototypes double parsePostfix(string expression); string getNextToken(string &amp;expression); void performCalculation(Stack&lt;double&gt; &amp;s, char op);  // Postfix arithmetic, implementing +, -, *, /  #include &lt;iostream&gt; #include \"console.h\" #include \"simpio.h\" #include \"stack.h\"  using namespace std;  const string OPERATORS = \"+-*x/\"; const string SEPARATOR = \" \";  // function prototypes double parsePostfix(string expression); string getNextToken(string &amp;expression); void performCalculation(Stack&lt;double&gt; &amp;s, char op);  int main() {     string expression;     double answer;     do {         expression = getLine(\"Please enter a postfix expression (blank to quit): \");         answer = parsePostfix(expression);         cout &lt;&lt; \"The answer is: \" &lt;&lt; answer &lt;&lt; endl &lt;&lt; endl;     } while (expression != \"\");     return 0; }  int main() {     string expression;     double answer;     do {         expression = getLine(\"Please enter a postfix expression (blank to quit): \");         if (expression == \"\") {             break;         }         answer = parsePostfix(expression);         cout &lt;&lt; \"The answer is: \" &lt;&lt; answer &lt;&lt; endl &lt;&lt; endl;     } while (true);     return 0; }  string getNextToken(string &amp;expression) {     // pull out the substring up to the first space     // and return the token, removing it from the expression      string token;     int sepLoc = expression.find(SEPARATOR);     if (sepLoc != (int) string::npos) {         token = expression.substr(0,sepLoc);         expression = expression.substr(sepLoc+1,expression.size()-sepLoc);         return token;     }     else {         token = expression;         expression = \"\";         return token;     } }  double parsePostfix(string expression) {     Stack&lt;double&gt; s;     string nextToken;          while (expression != \"\") {         // gets the next token and removes it from expression         nextToken = getNextToken(expression);         if (OPERATORS.find(nextToken) == string::npos) {             // we have a number             double operand = stringToDouble(nextToken);             s.push(operand);         }         else {             // we have an operator             char op = stringToChar(nextToken);             performCalculation(s,op);         }     }     return s.pop(); }  void performCalculation(Stack&lt;double&gt; &amp;s, char op) {     double result;     double operand2 = s.pop(); // LIFO!     double operand1 = s.pop();     switch(op) {         case '+': result = operand1 + operand2;             break;         case '-': result = operand1 - operand2;             break;             // allow \"*\" or \"x\" for times         case '*':         case 'x': result = operand1 * operand2;             break;         case '/': result = operand1 / operand2;             break;     }     s.push(result); }  Example run: Please enter a postfix expression (blank to quit): 5 4 * 8 2 / - 9 + The answer is: 25  Please enter a postfix expression (blank to quit): 1 2 3 4 + + + The answer is: 10   Please enter a postfix expression (blank to quit): 1 2 3 4 - - - The answer is: -2   Please enter a postfix expression (blank to quit): 1 2 + 3 * 6 + 2 3 + / The answer is: 3   Please enter a postfix expression (blank to quit): 2 3 4 + * 6 -  The answer is: 8      Slide  18  World's First Programmable Desktop Computer     The HP 9100A Desktop Calculator: the world's first programmable scientific desktop computer — really, the first desktop computer. (Wired, Dec. 2000)        RPN (postfix)   Special algorithm for trigonometric and logarithmic functions   Cost $5000 in 1968               ($37,000 today)   "
http://cs106b.stanford.edu/qt/install-confirm.html
"After installing Qt Creator, use this check step to confirm that your system is ready to build and run C++ programs that use the Stanford libraries.  Download zip and extract    Download this archive file: 📦 sample-project.zip   Un-zip the download contents  (on a Windows computer, click \"Extract all\") to a location of your choice. You should have a folder named sample-project with several files and folders inside.   Open and configure project A Qt Creator project includes a file named with a .pro extension. Double-clicking the .pro file opens the project in Qt Creator.    Find the sample-project.pro file and open it now.            If you are running on Windows and your File Explorer options are set to hide filename extensions, the file sample-project.pro will display the name sample-project.  You can change whether extensions are displayed in File Explorer by choosing menu item File-&gt;Options, select the \"View\" tab and under Advanced settings, uncheck \"Hide extensions for known file types\".  Click \"Apply\" button.           When opening a project for the first time, Qt Creator brings up a \"Configure Project\" panel for you to select the appropriate build kit (see screenshot below). The default kit should already be selected; it will match the component you selected when installing Qt Creator. Accept the default by clicking the \"Configure Project\" button.   If no kits are shown as available, review the installation instructions. You can repeat the steps to re-install if you missed selecting the required components.     Build the program C++ code must be compiled or built before it is run; this means converting the source code into executable binary code.     Click the Build icon  in the lower-left of the Qt Creator window.   Watch the build progress meter  in the lower-right. The first time you build a project, it can take a minute or more to compile the library code. When the bar turns green, it indicates the program successfully built.   Run the program Now that the program is built, you are ready to run it.     Click the Play/Run icon  in lower-left of window.        As shown in the screenshot below, the sample program prints a message to the console window and draws a smiley face to the graphics window.            ✔️ Congratulations, your computer is good to go!  "
http://cs106b.stanford.edu/qt/install-linux.html
"Below are basic instructions for installing on Linux that may work for your system, however, we are unable to provide further Linux support.  If you are unable to get Qt Creator working on your Linux system, please consider using another computer or working on a campus cluster computer.  1) Install prerequisites  If you're running Ubuntu, Debian, Mint, or any other Debian derivative, issue the following command in your shell:  sudo apt-get -y install build-essential openssl libssl-dev libssl1.0 libgl1-mesa-dev   If you're running some other variant of Linux, figure out a way to install the tools make, g++, and  gdb. (For example, on Fedora / Red Hat systems, you may be able to use the yum package manager.)  2) Download installer The Qt Creator official download site is https://www.qt.io/download-qt-installer. When you go to this site, it should detect that your computer is running Linux and recommend the installer \"Qt Online Installer for Linux\". Click the green \"Download\" button to download the installer.    3) Run installer The downloaded installer is named something like qt-unified-linux-x64-version-online.run and is likely located in your ~/Downloads directory. Run chmod +x qt*.run to make it executable, then run it by typing ./qt-unified-linux-x64-3.2.2-online.run (or whatever it is named).  The graphical installer launches and walks you through a set of steps. For most steps, you can use the default settings and simply click \"Next\" or \"Agree\" to move on, with the following exceptions:     At the Qt Account step, you will have to create your own Qt Account.   At the Select Components step:            Select the highest-numbered Qt version. As of April 3, the latest release is Qt 5.14.2. Do not select any version labeled \"Preview\" or \"Alpha\" or \"Beta\".       IMPORTANT: You must also select the Desktop gcc kit component. Expand the \"Qt\" triangle, then expand the triangle with Qt version number, then click the checkbox labeled \"Desktop gcc\". See the screenshot below.           (The screenshot has part of the version number scribbled out since the versions change so frequently; it is just shown as a general example of what the UI will look like.)    4) Confirm installation IMPORTANT: Follow the check step instructions to build and run our sample project that confirm your Qt Creator is installed properly and works correctly.  5) Configure settings (optional) For a better experience, we suggest changing some of the default settings, see our recommended configuration settings.  "
http://cs106b.stanford.edu/qt/install-mac.html
"1) Ensure system is up-to-date  Before installation, ensure your macOS operating system is current.  Select  menu -&gt; \"System Preferences\" -&gt; \"Software Update\" and check whether any OS updates are available. If so, install them first and only then proceed with the rest of this installation guide.  2) Install Xcode tools Apple's developer tools are bundled as a part of Xcode. Installing Xcode provides the C++ compiler that is used by Qt Creator.  To identify the correct version of Xcode to install, you need to know which OS you are running. Go to the  menu -&gt; \"About This Mac\" and read the macOS version number.     If you are running the macOS Catalina &gt;= 10.15, you can install Xcode directly from App Store using the instructions below.   If your macOS is 10.14 or older, you need an older version of Xcode, e.g. MacOS 10.14 is compatible with Xcode version 11.3. You can find older versions of Xcode at Apple Developer Downloads.   To install from App Store:     Select  menu - &gt; \"App Store…\".   Search for Xcode. Download and install.     Xcode is a very large app, so the download will take some time, 1-3 hours depending on your network connection speed.  3) Run Xcode once  After downloading Xcode, you have to actually launch the Xcode application one time to install its components. You can open Xcode using Spotlight (the magnifying glass at the top right of your screen) and typing in \"Xcode\". Click \"Agree\" to accept the License Agreement and enter your password if prompted. Watch the progress bar \"Installing components…\". When it finishes, you may exit Xcode and do not need to launch it ever again for this course.    4) Download the Qt Creator installer The Qt Creator official download site is https://www.qt.io/download-qt-installer. When you go to this site, it should detect that your computer is running MacOS and recommend the installer \"Qt Online Installer for Mac OS\". Click the green \"Download\" button to download the installer.    5) Run the Qt Creator installer The downloaded installer is named something like qt-unified-mac-version.dmg. Double-click to mount the disk image and launch the installer..  The graphical installer launches and walks you through a set of steps. For most steps, you can use the default settings and simply click \"Next\" or \"Agree\" to move on, with the following exceptions:     At the Qt Account step, you will have to create your own Qt Account.   At the Select Components step:            Select the highest-numbered Qt version. As of April 3, the latest release is Qt 5.14.2. Do not select any version labeled \"Preview\" or \"Alpha\" or \"Beta\".       IMPORTANT: You must also select the macOS kit component. Expand the \"Qt\" triangle, then expand the triangle with Qt version number, then click the checkbox labeled \"macOS\". If you are tight on disk space, you can un-check every other checkbox except for \"macOS\", as shown in the screenshot below.             6) Confirm installation IMPORTANT: Follow the check step instructions to build and run our sample project that confirm your Qt Creator is installed properly and works correctly.  7) Configure settings (optional) For a better experience, we suggest changing some of the default settings, see our recommended configuration settings.  "
http://cs106b.stanford.edu/qt/install-windows.html
"1) Download installer The Qt Creator official download site is https://www.qt.io/download-qt-installer. When you go to this site, it should detect that your computer is running Windows and recommend the installer \"Qt Online Installer for Windows\". Click the green \"Download\" button to download the installer.    2) Run installer The downloaded installer is named something like qt-unified-windows-version.exe. Double-click to run it.  The graphical installer launches and walks you through a set of steps. For most steps, you can use the default settings and simply click \"Next\" or \"Agree\" to move on, with the following exceptions:     At the Qt Account step, you will have to create your own Qt Account.   At the Select Components step:            Select the highest-numbered Qt version. As of April 3, the latest release is Qt 5.14.2. Do not select any version labeled \"Preview\" or \"Alpha\" or \"Beta\".       IMPORTANT: You must also select the MinGW 32-bit kit component. Expand the \"Qt\" triangle, then expand the triangle with Qt version number, then click the checkbox labeled \"MinGW 7.x.x 32 bit\". See the screenshot below. If you are tight on disk space, you can un-check every other checkbox except for \"MinGW 32 bit\", as shown in the screenshot below.           This screenshot shows the general UI for selecting the proper component. Note that we scribbled out the version numbers to avoid confusion since the versions change so frequently.    3) Confirm installation IMPORTANT: Follow the check step instructions to build and run our sample project that confirm your Qt Creator is installed properly and works correctly.  4) Configure settings (optional) For a better experience, we suggest changing some of the default settings, see our recommended configuration settings.  "
http://cs106b.stanford.edu/late
"  Hofstadter's Law: \"It always takes longer than you think, even when you take Hofstadter's Law into account.\"  The ground rules:          All assignments this quarter will be due on Fridays at 11:59pm Anywhere on Earth1. Students who submit their assignment by the deadline will receive a small \"on-time\" bonus applied to their assignment score.           All students are also automatically granted a penalty-free 48 hour extension on every assignment. This means that you can submit the assignment by Sunday at 11:59pm Anywhere on Earth, with no impact on your assignment grade. This grace period is meant to give built-in flexibility for any unexpected snags. Given the condensed end-of-quarter schedule, this policy may not apply to the last assignment of the quarter.           Late submissions are not accepted after the grace period expires, unless there is an exceptional situation that the teaching team has been made aware of, as described below.           We understand that exceptional circumstances may arise this quarter that prevent students from being able to submit assignments within the grace period. In situations like these, please reach out directly to the course staff (Chris, Nick, and Julie). We will work with you to make appropriate accommodations for your situation. In doing so, our philosophy will be to balance the challenges of the current moment with the desire to keep students on track in the course overall. The course has a steady weekly cadence of assignments, and falling far behind on any one assignment can result in a snowball effect on keeping up with the rest of the course. That all being said, please reach out to us and we will work with you to find the best route forward to stay on track.                      Note that our Paperless submission system displays due dates and submission times in Pacific Daylight Time (PDT). &#8617;          "
http://cs106b.stanford.edu/assignments/assign2/maze.html
"    A maze is a twisty and convoluted arrangement of paths that challenge the solver to find a route from the entry to the exit. This assignment is about using ADTs to represent, process, and solve mazes.  Mazes Labyrinths and mazes have fascinated humans since ancient times (remember Theseus and the Minotaur?), but mazes can be more than just recreation. The mathematician Leonhard Euler was one of the first to analyze plane mazes mathematically, and in doing so founded the branch of mathematics known as topology. Many algorithms that operate on mazes are closely related to graph theory and have applications to diverse tasks such as designing circuit boards, routing network traffic, motion planning, and social networking.  This project focuses on a particular type of maze known as a perfect maze. A perfect, or simply-connected, maze has no loops and no inaccessible areas. Any two locations within a perfect maze are connected by exactly one path.  The image below shows a perfect maze and the path from the entry at upper left to exit at lower right:    Grid and GridLocation A maze can be modeled as a two-dimensional array where each element is either a wall or a corridor. The Grid class from the Stanford library is a good fit tool for representing a maze.  It provides the abstraction of a two-dimensional array in a safe, encapsulated form with various client conveniences. We use a bool as the element, storing true for a cell that is an open corridor and false for a wall.  Access to grid elements is generally by row and column, e.g. grid[row][col]. Alternatively elements can be selected by GridLocation.  GridLocation is a small struct type that pairs the row and column together into one aggregate type.  A struct is a C++ user-defined type consisting of a defined set of named fields of heterogeneous type.   GridLocation chosen;  chosen.row = 3;  chosen.col = 4;  if (maze[chosen]) // equivalent to maze[3][4]      GridLocation exit = { maze.numRows()-1, maze.numCols()-1 }; // last row, last col   cout &lt;&lt; maze[exit] &lt;&lt; endl;  References    Lecture slides on Grid   Documentation for Grid   Section 6.1 of the textbook introduces struct types   Header files grid.h and gridlocation.h within the starter project subfolder lib/StanfordCPPLIb/collections/   Reading a maze file A maze file contains a maze written in text format. Each line of the file corresponds to one row of the maze. Within a row, the character @ is used for walls and - for corridors. Here are the first few lines of a sample maze file:   -----@-----------  @@@@-@@@@@@@@@-@@  ---@---------@---  -@@@@@@@@@@@-@-@-  -----@---@---@-@-   A maze file can optionally include a solution at the end, expressed as a sequence of locations along the path from entry to exit.  A completed version of the function bool readMazeFile(string filename, Grid&lt;bool&gt;&amp; maze)   is provided in the starter project. The provided function correctly reads a well-formed maze, which is confirmed by the provided unit tests. First read over the function and its unit tests. Ask questions if you find anything unclear.  Although readMazeFile does a great job reading correct files, it does a poor job if asked to read a malformed file. Since it makes no effort to detect problems, it generally blunders through, misinterpreting the data, and possibly crashing on bad inputs.  Add error detection Your first task is to improve readMazeFile by making it robust to malformed input.  There are two specific issues in the file format that you are to detect and report:     A maze row that is longer or shorter than the other rows.            Each maze row is required to have same length as all the others.           A maze location containing a character that is not @ or -.            The valid options for a location are open or wall. Anything else is an error.           Use the error function from the header \"error.h\" to report an error. This function is used to report a fatal error. When you call error it halts the program right here and reports the message you provided:  error(\"Here is my message about what has gone wrong\");   Construct tests and maze files We've provided some unit tests and one badly malformed maze file. You are to add student tests that further verify that your maze reading is now robust. You will need to create additional malformed files. Maze files are just ordinary text files placed into the res/ folder of your project. You can edit these files in Qt Creator. The project resource files are listed under Other files -&gt; res. Your program can open a resource file by specifying the path to open as \"res/myfilename\".  Note the use of the special kind of test case EXPECT_ERROR in our provided test. An EXPECT_ERROR test case evaluates an expression, expected that the operation with raise an error. While the test is running, SimpleTest framework will catch the error, note that it was generated, and then resume. Because the error that was raised was expected, the test case is considered to be passed.  If an error was expected but didn't materialize, the test case fails. (Note this is opposite of the regular EXPECT and EXPECT_EQUAL tests which do not expect errors and treat a raised error as a test failure). More information on the different test macros and how they all work can be found in the CS106B Testing Guide     Q5. Describe the malformed maze files you created in order to verify the robustness of your maze reading.   Check solution The last line of a maze file must either be a blank line or can optionally includes the solution written as a Stack of GridLocation. The readMazeFile function includes the correct code to read the Stack and validate it is syntactically well-formed. To confirm that the path is a valid solution, it calls the function checkSolution.  The function bool checkSolution(Grid&lt;bool&gt;&amp; maze, Stack&lt;GridLocation&gt; path)   is intended to verify that a path meets all of the necessary criteria to be a correct solution:     The path must start at the entry (upper left corner).   The path must end at the exit (lower right corner).   Each location in the path is within the maze bounds.   Each location in the path is an open corridor (not wall).   Each location is one cardinal step (N,S,E,W) from the next in path.   The path contains no loops, i.e. a location appears at most once in the path.   This is a lot of things to check! However, writing this function now is going to pay off big time when you later use it to test your path-finding algorithm. Be sure to very thoroughly test your checkSolution on a variety of invalid paths so that you can be confident it is the oracle of truth when it comes to validating a solution. Your future self will thank you.     Q6. After you have written your tests, describe your testing strategy to determine that your checkSolution works as intended   Once your maze-reading is bullet-proofed against all manner of problems, you're ready to go on to display the maze and code the algorithm to solve it.  Drawing the maze The Stanford C++ library has extensive functionality for drawing and interacting with the user, but we generally don't ask you to dig into those features. Instead, we have supplied the graphics routines you need pre-written in a simple, easy-to-use form. For this program, the provided mazegraphics.cpp module has functions to display a maze and highlight a path through the maze.  Read the mazegraphics.h header file in the starter project for details of these functions:    MazeGraphics::drawGrid(Grid&lt;bool&gt;&amp; grid)   MazeGraphics::highlightPath(Stack&lt;GridLocation&gt; path, string color)   After reading in a  maze (and validating that it is well-formed), you simply call the MazeGraphics::drawGrid to display the maze. The function MazeGraphics::highlightPath is later used to mark the cells along a path as part of animating the search for a solution. Note that when calling these functions, you must call them using their full name (including the weird looking MazeGraphics:: prefix). We will talk more about what this notation means a little later on in the quarter!  Solving a maze using breadth-first search (BFS) There are a wide variety of algorithms for solving a maze. Solving a maze can be seen as a specific instance of a shortest path problem, where the challenge is to find the shortest route from the entrance to the exit. Shortest path problems come up in a variety of situations such as packet routing, robot motion planning, analyzing gene mutations, spell correction, and more. In the case of the perfect maze, the shortest path is also the only path, but the general process is the same regardless.  Breadth-first search (BFS) is a classic and elegant algorithm for finding a shortest path. A breadth-first search reaches outward from the entry location in a radial fashion until it finds the exit. The first paths examined take one hop from the entry. If any of these reach the exit location, you're done. If not, the search expands to those paths that are two hops long. At each subsequent step, the search expands radially, examining all paths of length three, then of length four, etc.), stopping at the first path that reaches the exit.  Breadth-first search is typically implemented using a queue. The queue stores partial paths that represent possibilities to explore. The paths are processed in order of increasing length. The first paths enqueued are all length one, followed by the length two paths, and so on. Given the FIFO handling of the queue, all shorter paths are dequeued before the longer paths make their way to the front of queue, ready for their turn to be processed.  At each step, the algorithm considers the current path frontmost in the queue. If the current path ends at the exit, it is a complete solution. If not, the algorithm takes the current path and extends it to reach locations that are one hop further away in the maze, and enqueue those extended paths to be examined later.  To represent a path, a Stack of GridLocation is a good choice, as it cleanly supports the needed operations to add/examine the element at the end of the path. Putting these paths into a queue for processing means you'll have a nested ADT, a Queue&lt;Stack&lt;GridLocation&gt;&gt;. A nested container type looks a little scary at first, but it is just the right tool for this job.  Here are steps followed by a breadth-first search:     Create a queue of paths. A path is a stack of grid locations.   Create a length-one path containing just the entry location. Enqueue that path.            For simplicity, assume entry is always the upper-left corner and exit in the lower-right.           Dequeue shortest path from queue.   If this path ends at exit, this path is the solution!   If path does not end at exit:            For each viable neighbor of path end, make copy of path, extend by adding neighbor and enqueue it.       A location has up to four neighbors, one in each of the four cardinal directions. A location is viable if it is within the maze bounds, the cell is an open corridor (not a wall), and it has not yet been visited.           Repeat steps 3-5 until path reaches exit.   One issue that is a bit subtle is that you must avoid repeatedly revisiting the same location in the maze or creating a path with a cycle, lest the search get stuck in a infinite loop.  For example, if the current path leads from location r0c0 to r1c0, you should not extend the path by moving back to location r0c0.  A common strategy for tracking where you have already been is to keep a Set of locations to which you add each location as you visit it. Checking whether a location is contained in the visited set lets you know whether to consider or skip this location.  As your algorithm hunts for a solution, call the function MazeGraphics::highlightPath function to visually mark the current path on the graphics window so the user can follow along with the algorithm.  Once you have a working solver, unit-testing is a piece of cake because earlier you wrote the awesome checkSolution function. After solving a maze, use your unit test verify that your path meets all the criteria to be valid. Super neat! Your work here is done, congratulations!👏  Notes on Collection ADTs    For solving the maze, the Stack with its LIFO behavior is ideal for storing a path. The first entry pushed on the stack is the starting point and each subsequent point in the path is pushed on top. The FIFO Queue is just what's needed to track those partial paths under consideration. The paths are enqueued (and thus dequeued) in order of increasing length. A Set is particularly handy if you need to be able to quickly determine membership  (is this element contained in the set?).   The assignment operator work as expected for all our ADTs. Assigning from one Stack/Vector/Set/etc to another will create a copy of the ADT with a copy of the elements.   Be on your toes about making sure that your template types are always properly specialized and that all types match. Using Vector without specifying the element type just won't fly, and a Vector&lt;int&gt; is not the same thing as a Vector&lt;double&gt;. The error messages you receive when you have mismatches can be cryptic and hard to interpret. Bring your template woes to the forum and we can help untangle them with you.   References There are many interesting facets to mazes and much fascinating mathematics underlying them. Mazes will come up again several times this quarter. Chapter 9 of the textbook uses a recursive depth-first search as path-finding algorithm. At the end of the quarter when we talk about graphs, we'll explore the equivalence between mazes and graphs and note how many of the interesting results in mazes are actually based on work done in terms of graph theory.     Walter Pullen, Maze Classification. http://www.astrolog.org/labyrnth/algrithm.htm  Website with lots of great info on mazes and maze algorithms   Jamis Buck. Maze Algorithms. https://www.jamisbuck.org/mazes/ Fun animations of maze algorithms. He also wrote the excellent book about Mazes for Programmers: Code Your Own Twisty Little Passages.   Extensions     Instead of reading pre-written mazes from a file, you could instead generate a new random maze on demand. There is an amazing (I could not resist…) variety of algorithms for maze construction, ranging from the simple to the sublime. Here are a few names to get you started:  backtracking, depth-first, growing tree, sidewinder, along with algorithms named for their inventor:  Aldous-Broder, Eller, Prim, Kruskal, Wilson, and many others.   Try out other maze solving algorithms. How does BFS stack up against the options in terms of solving power or runtime efficiency? Take a look at random mouse, wall following, depth-first search (either manually using a Stack or using recursion once you get the hang of it), Bellman-Ford, or others.   There are many other neat maze-based games out there that make fun extensions. You might gather ideas from Robert Abbott's http://www.logicmazes.com or design a maze game board after inspiration from Chris Smith on mazes.  "
http://cs106b.stanford.edu/office_hours
"Overview Julie, Chris and Nick will be holding weekly office hours throughout the quarter for you to discuss any questions you might have about assignments, course material or simply Computer Science and life in general. Like all class sessions, these office hours will be held remotely over Zoom and links to the zoom meetings will be posted here. This quarter, we will be holding two different kinds of office hours:     Individual office hours: one on one office hours in which you can get help on particular problems you are having in the assignments or in which you can discuss personal circumstances with Julie, Chris or Nick. To participate in these office hours, simply join the Zoom meeting during the scheduled window and you will be placed in a waiting room until your turn comes.   Group office hours: office hours held in a group of students and led by Julie, Chris or Nick. High-level assignment help and conceptual guidance will be provided during these office hours, as well as one-on one help (subject to how many students are in attendance). To participate in these office hours, simply join the Zoom meeting during the scheduled window.   The LaIR is a different type of office hours that is staffed by our courageous fleet of section leaders from 5pm-9pm PDT every Sunday-Thursday and from 9-11am PDT every Monday - Friday, starting Sunday, April 12. At the LaIR, students can get both debugging and conceptual help. For more information on the LaIR, check out this page.   Calendar  "
http://cs106b.stanford.edu/assignments/assign1/perfect.html
"  This part of the assignment focuses on giving you practice with C++ expressions, control structures, and functions, as well as testing and debugging your code. In addition, to writing code tests in the perfect.cpp file, you will also be filling in answers to short answer questions in short_answer.txt as you work through this exercise. Make sure to answer all the questions (each one is highlighted, and labeled Q1, Q2, etc.)!  Mersenne primes and perfect numbers  Last year, there was a rare finding of a new Mersenne prime. A prime number is one whose only divisors are 1 and the number itself. A Mersenne prime is a prime of the form 2n -1. The prime number 31 can be expressed as 25-1, and thus is an example of a Mersenne prime.  Mersenne primes are quite elusive, the one just found is only the 51st known and has almost 25 million digits! Verifying that the found number was indeed prime required almost two weeks of non-stop computing. The quest to find further Mersenne primes is driven by the Great Internet Mersenne Prime Search (GIMPS) a cooperative, distributed effort that taps into the spare cycles of a vast community of volunteer machines.  Back in 400 BCE, Euclid discovered an intriguing relationship between perfect numbers and the Mersenne primes in that if 2k-1 is prime, then 2k-1*(2k-1) is a perfect number (which will be the focus of this part of the assignment).  Those of you enrolled in CS103 will appreciate this lovely proof of the Euclid-Euler theorem.  This exercise is an exploration into efficient algorithms for finding perfect numbers. A perfect number is an integer that is equal to the sum of its proper divisors, e.g. those numbers that evenly divide it, excluding the number itself. The first perfect number is 6 because its proper divisors are 1, 2, and 3 and 1 + 2 + 3 = 6.  The next perfect number is 28 which equals the sum 1 + 2 + 4 + 7 + 14.  Brute force One way to find perfect numbers is by brute force. To determine if a given number is perfect, calculate the sum of all of its divisors and compare the sum to the number - if they're equal, you've found a perfect number! If you try this on every integer starting from 1, you eventually encounter the perfect numbers along the way.  Here is a python function that performs a brute-force search for perfect numbers.  def divisor_sum(n):     total = 0     for divisor in range(1, n):         if n % divisor == 0:             total += divisor     return total  def find_perfects(stop):     for num in range(1, stop):         if num == divisor_sum(num):             print(\"Found perfect number: %d\" % num)  The same code is now expressed below in C++. If your CS106A was taught in Python, comparing and contrasting these two may be a helpful way to start adapting to the language differences. If instead your prior course/experience was with Java/Javascript, just sit back and enjoy how C++ already seems familiar to what you know!  // Note: long is a C++ type is a variant of int that allows for a  // larger range of values. For all intents and purposes, you can  // treat it like you would an int. long divisorSum(long n) {     long total = 0;     for (long divisor = 1; divisor &lt; n; divisor++) {         if (n % divisor == 0) {             total += divisor;         }     }     return total; }  void findPerfects(int stop) {     for (long num = 1; num &lt; stop; num++) {         if (num == divisorSum(num)) {             cout &lt;&lt; \"Found perfect number: \" &lt;&lt; num &lt;&lt; endl;         }     } }   Runtime observations The starter project contains the above code pre-written. Your first task is going to be to run the code and make some observations about how long it takes the program to run. Important note: If at any point your program takes more than 5 minutes to run to completion, you can just stop the program and report the runtime as \"&gt; 5 mins\". Here are the steps we'd like you to do:     Open the project in Qt Creator and build and run the program as given. The program reports the time in seconds  to search through the first 40000 numbers. Note this time down.   Select the main.cpp file in the QT editor and change the value of the argument to findPerfects to be twice as large (80000 numbers). Build and re-run and note that time down.   Repeat the last step for a few more doublings of the input size.   Input this timing data into Q1 in short_answer.txt.   Use the data to get a rough idea of the relationship between the argument size and the amount of time required. It may help to plot these values on a graph, if you have the capability to do so.   What you should notice among the time values in your table is that doubling the size of the input doesn't just cause the time required to also double, it goes up by a factor of 4. Rather than a linear relationship, we've got a quadratic relationship between the input size and the program execution time.  If you consider the amount of work used to search the first N numbers, searching the first 2*N numbers does all of that same work plus a lot more since it now needs to test larger numbers as well!    Q2: What is it about the algorithm that causes it take more time to test larger numbers than to test smaller numbers?   A quadratic function grows pretty steeply compared to a line. The first four perfect numbers are found pretty quickly (6, 28, 496, 8128), but that fifth one is quite a ways off - in the neighborhood of 33 million!    Q3: Extrapolating from the data you gathered, make a prediction of how long it would take the brute force algorithm to reach the fifth perfect number.   If you are graced with a very beefy computer and a surfeit of patience, let brute force search up to the fifth one and see how close your prediction is to actual. Later in this exercise we will apply a finesse move to get that fifth number without all the sweat.  This is your first foray in algorithmic analysis, a topic we will have explore in much greater detail throughout the course, starting next week!  As a fun aside, if you have access to a python environment, you can attempt similarly-sized searches using the python version of the program to see just how much slower an interpreted language (Python) is compared to a compiled language (C++). Check out the Python vs C++ Showdown I posted to the Ed discussion forum.  Using SimpleTest In CS106B, you will use a unit-test framework called SimpleTest to test your code. Stop here and read our guide to testing to be introduced to use this framework. SimpleTest is somewhat akin to the \"doctest\" features you may have used in CS106A. If you're not familiar with doctests, don't sweat - the testing guide above has everything you need to know about how testing your code will work in CS106B.  Now, scroll to the bottom of the perfect.cpp file and review the existing test cases. Take the following steps to run the existing test cases to see SimpleTest in action.     Edit the main function in main.cpp to change the argument to runSimpleTests from NO_TESTS to SELECTED_TESTS.   Re-build and run the program. When prompted, select the perfect.cpp tests to run. The given code should pass all the tests, so this shows you what a successful sweep through all the tests looks like.   There is no such thing as as negative perfect number, thus isPerfect should return false for any negative numbers. Will you need to make a special case or does the code already handle it? Let's investigate…            Look at the code and make a prediction about what happens for a negative input.       Add a new test case that runs isPerfect on a few different negative inputs. The expected output of all of these test cases should be false.       Run those tests to confirm that the code behaves as expected.           Introduce a bug into divisorSum (e.g. erroneously initialize total to 1 instead of 0). Rebuild and run the tests again. This should let you see how test failures are reported.            Q4: Do any of the tests still pass even with this broken function? Why or why not?       Be sure to undo the bug and restore divisorSum to a correct state.           Add a test case of your own but deliberately make the test case expect something erroneous (e.g. isPerfect(5) returns true). Run this test case. What happens?            Q5: Can the test framework detect that the test case is bogus?       This example serves as a reminder to take care in constructing your test cases! If your tests aren't correct, then you wouldn't be able to properly identify if your code is correct or not! Be sure to remove that bogus test so it won't further confuse your results. Your goal is a clean green record for all tests.           Streamlining and more testing As you observed earlier, searching up to the fifth perfect number and beyond is quite pokey. There is a neat little optimization you can apply that can significantly streamline the job.  The function divisorSum runs a loop from 1 to N to find divisors but in fact, this is quite wasteful, as we truly only need examine divisors up to the square root of N. Along the way, we can work out what the corresponding pairwise factor for a given divisor is without having to loop up to it. Each divisor that is less than the square root is paired one-to-one with a divisor that is greater than the square root. Take a moment to carefully think about why this is so and how you would rearrange the code to capitalize on this observation.  Copy and paste divisorSum and make a smarterSum function. Edit smarterSumto apply the optimization. The C++ library function sqrt can be used to compute a square root.  Before you put smarterSum into production, first thoroughly test it. Because you already have the vetted function divisorSum, a neat testing strategy here is to use an EXPECT_EQUALtest to compare the result from divisorSum(n) to the result from smarterSum(n) and ensure they are equal.  Rather than just pick random test values of n, brainstorm about why certain values might make good candidates. As an example, trying picking a number like n=25 (which has an square root that is an integer value) to ensure there is no off-by-one issue on the stopping condition of your new loop. You must add at least 2 new tests for smarterSum.    Q6: After you have written your tests, describe your testing strategy to determine that smarterSum was working as expected.   Once you have confirmed that smarterSum operates equivalently to divisorSum, swap this version into the search for perfects and re-run to see the change in performance. Important note: If at any point your program takes more than 5 minutes to run to completion, you can just stop the program and report the runtime as \"&gt; 5 mins\".    Q7: Re-run some of the same sized searches as before (input size of 40000, 80000, etc.) and jot down the new times to compare to your earlier results. Record these times in the empty table in short_answer.txt.   (You may have to go up to larger sizes to be get enough time to measure, the optimization is a significant improvement!)   Q8: Make a prediction: how long will the optimized code take to reach the fifth perfect number?   Our previous algorithm grew at the rate N2, while this new version is N√N, since we only have to inspect √N divisors for every number along the way. If you plot runtimes on the same graph as before, you will see that they grow much less steeply than the runtimes from our previous experiment.  Turbo-charging Now that your computer is good and tired, it's time to take a more elegant approach to this problem. Over two thousand years ago, that clever guy Euclid discovered an intriguing pattern in the perfect numbers and was able to prove that if 2k-1 is prime then 2k-1 multiplied by (2k-1) is a perfect number.  Add a new search function findByEuclid to perfect.cpp that uses Euclid's method to find the first n perfect numbers and collect into a Vector.    Start by setting k = 1.   Calculate m = 2k-1 (use the C++ library function pow)   Determine whether m is prime or composite. (A simple isPrime helper that uses brute force loop is just fine)   If m is prime, then calculate 2k-1 * (2k-1). This is the associated perfect number. Add it to the result vector.   Increment k and repeat until n perfects are found.   The call findByEuclid(n) returns a Vector&lt;long&gt; whose elements are the first n perfect numbers.  What will be your testing strategy to verify that this vector has the correct contents? One possibility is a test case that confirms each number is perfect according to your earlier function, e.g. EXPECT(isPerfect(num)) for each num in vector. Or alternatively, you could compare two vectors for equality using an EXPECT_EQUAL test like so:  STUDENT_TEST(\"Confirm first 2 perfect numbers are 6 and 28\") {     Vector&lt;long&gt; goal = {6, 28};     EXPECT_EQUAL(findByEuclid(2), goal); }   Add at least 3 new test cases to verify that your findByEuclid is correct.    Q9: What test cases did you use to verify that your new function works correctly? Please give a brief description of your testing strategy.   A call to findByEuclid(5) will near instantaneously find the first five perfect numbers. Woah! Quite an improvement over brute force, eh?  This version is so lightning fast that it will quickly reach values that are too large to fit in a long.  How many perfect numbers can you find before you overflow (an overflow is characterized by the large number you're incrementing suddenly becoming unexpectedly negative…)?  Back in 400 BC, Euler worked out the first eight perfect numbers himself— not too shabby for a guy with no electronics!  Hooray for algorithms! One of the themes for CS106B is to explore the tradeoffs between algorithm choices, especially as it relates to program efficiency. The differences between the brute force and Euclid's approach is striking.  Although there are tweaks (such as the square root trick) that will improve each algorithm relative to itself, the biggest bang for the buck comes from starting with a better overall approach. This result foreshadows many of the interesting things to come this quarter.  To complete this part of the assignment submit your perfect.cpp file which should include the following components:    Smarter sum: correct implementation of smarterSum function, at least 2 new test cases to compare to divisorSum   Euclid's: correct implementation of findByEuclid function to quickly find perfect numbers, at least 3 new test cases to verify correctness of function   Finally, add to the comments in perfect.cpp to share with your grader a little something about yourself and offer an interesting tidbit you learned in doing this exercise (be it something about C++, algorithms, number theory, how spunky your computer is, or something else exciting!)   You will submit your short_answer.txt file after completing the next portion of the assignment. Make sure that at this point, you've completed questions 1 to 9 in that document. "
http://cs106b.stanford.edu/lectures/sets-maps/qa.html
"Lecture 6 Questions and Answers (Exported from Zoom Q&amp;A log)  Q: Can you play NASA next?  A1: gotchu   Q: How's your friday going?  A1: good! how's your day going?   Q: YES NEVERMIND  A1: :)   Q: where are they sending these humans?  A1: to the international space station!   Q: nice!  A1: live answered   Q: can we get a link to the spotify playlist? the only one that pops up is Brahm's one for 106A lol  A1: It is at end of the quick links on the cs106b home page  A2: https://open.spotify.com/playlist/0vxLd6fJpRfMPm0DoXltqH?si=vkTT7-f-RwOIsV-tQzXBTw  also linked form the course website like juli ementioned above!   Q: Is SPACE  the same   as it is in Gregg's code?  A1: It is the space character, e.g. ' ' (note the single versus double quotes)   Q: nice! thanks  A1:   Q: Is there a way to make the lecture videos downloadable so that I can watch offline if my wifi cuts out?  A1: Nick answered this on Ed — search ther to see the instructions  A2: https://us.edstem.org/courses/335/discussion/27806   Q: Is the Queue data structure only defined in the Stanford Library? Or is there an equivalent in the Standard libraries?&lt;/i&gt;  A1: There is an std::queue also  A2: http://www.cplusplus.com/reference/queue/queue/   Q: Does const fix this issue?  A1: Not sure what you mean, if the Queue were const, you would not be able to modify it (i.e. would not be allowed to dequeue()   Q: If you pass a queue into a function will it lose its sense of size like an array or will you still be able to access its size within the function?  A1: It will retain its size   Q: if the for loop printing out the queue skips 1 index every time, shouldn't the queue left behind be {2, 4, 6} rather than {4, 5, 6}?  A1: dequeue always pulls from the front, so the 3 iterations of loop remove 1, 2,3, leaving 4,5,6 in queue   Q: I was thinking for (i = init; const q.size()…)  A1: the test expression of the for loop is reevaluated each time through loop. See slide 14 where Chris pulled the size outside of loop so it not updated as the the queue contents change   Q: are we expected to use postfix in our code?  A1: Do you mean for variable increment? In most cases, prefix and postfix are entirely interchangable   Q: Is it possible for to briefly summarize the push.wordstack correction/clarification that chris made earlier?  A1: I would recommend that you review the lecture video when it is posted. He went over it in the first few mintues   Q: how do you know when to stop popping for each operation?  A1: A binary operator pops the top 2 values   Q: Does this only work two numbers at a time? Would something like 1 2 3 * return 6?  A1: 1 2 3 * is malformed, I think you intend another operator after the * that would apply to the 6 and the 1   Q: Oh! I can test myself. :)  A1:   Q: How do we get this to work in our terminal?  A1: Download the lecture project from the top of the web page with lecture slides (see entry for today under Lectures tab) and open pro file in Qt Creator   Q: Whar is case in that example?  A1: live answered   Q: What was \"case\" under the while loop? What did that mean? Is that like an if?  A1: live answered   Q: what is switch(op)?  A1: live answered   Q: Could you do continue instead of break so it doesn't have to check the other cases?  A1: break jumps out of the switch, skipping all other cases, which sounds like what you are looking for. continue only applies within loops to advance to next iteration   Q: Is the switch op generally better to use than else/if loops?  A1: swtich works well when you have a list of options where the test aobut which case to enter is comparing an integer value to a set of constants, but for anything more complex, if/else is your only option   Q: any idea what time the assignment will be up?  A1: ETA tomorrow afternoon   Q: On assignment 1 it says that hw is due tonight for a bonus but it can also be submitted up until Sunday night. Just wanted to clarify that this still holds.  A1: Yes, our plan is for all assignments to be due end of day Friday, grace period starts then and extends to end of day Sunday   Q: Is it still true that we can turn the assignment in as late as Sunday and just lose the \"bonus\"? That is what was written at the top of Assignment 1.  A1: Yes, our plan is for all assignments to be due end of day Friday, grace period starts then and extends to end of day Sunday   Q: Baby I got your number  A1: I'm gonna make you mine   Q: What is the inside joke?  A1: Google  Jenny 867 5309   Q: does everything in the set have to be the same type  A1: Yes. All of the collections are homogenous with regard to element type   Q: what is the difference between empty() and isEmpty()?  A1: the name of the operation on string is called empty, a similar operation on queue, stack, vector, etc is called isEmpty   Q: can you manually type a set using some form of bracket?  A1: live answered   Q: Can we nest sets in sets?  A1: Yes, you can!   Q: At a low level, why is a set faster than a vector?  A1: You'll have to wait about 4 weeks before we can tell how it's so darn smart   Q: a bit of an under the hood question but what makes the sets so make compared to other data types?  A1: You'll have to wait about 4 weeks before we can tell how it's so darn smart (hint: sorting and/or hashing)   Q: Sets don't have indexes?  A1: Nope   Q: Is this in contrast to Python  A1: sorry, I am missing the context for your question. can you clarify?   Q: Can we also nest maps in maps, vectors in vectors, etc.?  A1: Yes!   Q: Can you convert a vector into a set?  A1: you could do a foreach loop over the vector and add each to the set, any duplicate elements would be coalesced   Q: what does boolalpha on the print function do again?  A1: It changes the format for printing a boolean from the default numeric representation (0/1) and outputs as string names (true/false)   Q: I thought .size returns size_t type  A1: .size on string does return size_t, but our collections specify return type of int. The distinction between signed and unsigned is more of a CS107 topic, keep progessing and you'll get all the gory details   Q: to print a boolean, wouldn't it be simpler to convert it to a string? or is that not possible  A1: If you want to print a boolean result true/false, boolalpha is an easy way to get that.   Q: can you pick the type of sorting order  A1: You control ordering by changing the comparison operation for the element type. The mechanics of this are a bit advanced for this course, but CS106L will go through that.   Q: Exciting! I can't wait to go fast. Vroom vroom :)  A1: Me too!   Q: can you add a set and a hash set?  A1: Yes, you can   Q: Is there an operand for the symmetric difference?  A1: No built-in, but you could construct with a compound expression   Q: Will != return false if only some of the elements match?  A1: yes. for two collections to be equal must contain exactly same elements, anything else is not equal   Q: Why would AB-  BC (sets)  yield A and not AC?  A1: Yes, difference is elements in first that are not in second. It sounds like you are looking for symmetric difference? You could construct that out of a compound expression, but there is no built-in for that   Q: is it good practice to not indent ifdef?  A1: Generally you don't — preprocesor directives operate outside the normal C++ language flow   Q: if you added a duplicate word to a set, would it just ignore it?  A1: Yes, add an element already in the set has no effect   Q: Why were there no curly brackets on that if statement?  A1: If there is only one statement, the curly braces are optional, but it is allowed (good even) to always use the curly braces even when they are not strictly required   Q: So if this was a set, we wouldnt need the if statement that makes sure a word doesnt repeat wouldnt be necessary?  A1: Yep, you could remove it and it would have no change if the data type were a set   Q: why does he use #define  again?  A1: Advanced ninja powers :-). Don't worry too much, it's specific to this kind of example where we want to have parallel versions of the same code   Q: how does while (input » word) { work?  A1: the extraction operator (») returns a boolean result that indicates whether the word just read was the last one in the file (you have hit end of file or error)   Q: Can a linked list be considered a map?  A1: a Map might be implemented using a map   Q: random mac question: how does chris switch between applications so quickly; it looks like a panel of applications on his view  A1: Command-tab   Q: can maps store different data types?  A1: All keys are homogenous type, all values are homogenous type, but those types can be set to what you need (i.e. int keys, string values or string keys and Vector values and so on)   Q: awesome thanks!  A1:   Q: what is the  on m[key]?  A1: Typo :-) We will remove it later   Q: what does the br stand for in value ?  A1: Typo, we will fix on the slides!   Q: lol great content today  A1: Thanks, Chris is killin it!   Q: are you able to nest maps like you can nest dicts in python?  A1: Yes!   Q: Are there any unsorted maps?  A1: HashMaps are unsorted   Q: is there debugging in OH or no  A1: live answered   Q: yes we love today's content!! thanks chris  A1: live answered   Q: where is the next Q&amp;A?  A1: live answered   "
http://cs106b.stanford.edu/lectures/stacks-queues/qa.html
"Lecture 5 Questions and Answers (Exported from Zoom Q&amp;A log)  Q: can we add songs to the playlist?  A1: yeah! I can make it public on the website   Q: hi! quick pset question before lecture. when making the isPrime helper, can we insert a break?  A1: yes, break is used to exit a loop early   Q: Do grids need to be a perfect square, or rather a rectangle?  A1: live answered   Q: Can grid be rectangular? 3x5? Or only square?  A1: live answered   Q: a grid can be a rectangle right  A1: live answered   Q: square or rectangular?  A1: live answered   Q: is a grid analagous to a numpy array in python?  A1: Yes, similar abstraction, many languages have support for multi-dimension arrays   Q: is default grid value zero?  A1: For integers, yes, for other types it would be the default value for type, e.g. empty string   Q: so matrix[0][1] is like matrix[y][x]??  A1: Yes, row then column   Q: do you need to import something to use the grids?  A1: #include grid.h   Q: are grids used for image processing?  A1: yes!   Q: Can you ask a grid its size and it tells you how many rows/collums it has?  A1: Yes, g.numRows() is number of rows and g.numCols() is number of columns   Q: Can i switch value between grids? For example change matrix[1][0] to matrix [0][1]  A1: there is not a transpose function that does this for you, but you could write it yourself   Q: can you multiply two grids (similar to multiplying matrices)  A1: There is no mulitply operation built-in to Grid, but you could write your own   Q: why is r not size_t? can the number of rows be negative?  A1: It really ought to be, but in 106B we tend to try to avoid the notion of signed/unsigned and postpone that discussion until 107   Q: for the traversing grid example, why did we need to include the second cout endl; line after the inner for loop?  A1: It advances down a line in the output at end of each row   Q: When using resize(): Does return to default values mean that every [r][c] is empty in the resized grid? So is resize() basically the same thing as declaring a new empty vector altogether?  A1: there is an optional retain parameter that indicates that you want it to retain any values, otherwise it discards and reinitializes all elements to default   Q: Could you repeat why the type should be bool in Grid?&lt;/i&gt;  A1: The element type is chosen based on what you are trying to store, if the information was just a yes/no for each location, bool would be appropriate   Q: In C++, is a color is a single number rather than a tuple of 3 numbers?  A1: Typically a color will be represented usingt hree  8-bit numbers, which can be mashed into one 32-bit int (including 8-bits of transparency/alpha)   Q: do you recommend we follow along coding?  A1: There is an archive of the lecture project on the website (see on lecture page for 4/15) you can dowloand that zip, and open project in QT and follow along   Q: for the for each loop will the complier throw an error and say that color variable hasnt been used yet?  A1: I am not sure what you are referring to, can you clarify?   Q: Since you probably won't modify the pallette, is it still better to use the direct reference (&amp;)?  A1: live answered   Q: does it make a difference whether the &amp; is next to the variable type or the variable name?  A1: The &amp; can go in next to typename or next to variable name, means the exact same thing.   Q: how do we read getClosestColor(palette, pixels[r][c])?  A1: There is an archive of the lecture project on the website (see on lecture page for 4/15) you can dowloand that zip, and open project in QT and then study the code at your leisure   Q: what does #04182B represent?  A1: It is a hexadecimal color string (used in html/web), first two digits are amount of red, next two are green, last two are blue   Q: Do most filters use a color palette? How big do these lists of hexidecimals get?  A1: A transform style fitler might be palette-based, others do other kinds of manipulation (convert to grayscale, boost, sharpen, etc) that are not pallette-based   Q: what exactly does the &amp; represent again?  A1: It indicates that the parameter is passed by reference   Q: How to run only a part of the main in Qt?  A1: A C++ program starts at main and executes the entire function.   Q: Im still a little confused why we passed the palette by reference  A1: Solely for reasons of efficiency. Otherwise we make a full copy of all the values, which can be slow for a large data type   Q: Friday is just the early due date right? And final due  date is Sunday.  A1: There is one due dat and tha's Friday. Beyond that is a grace period that extends to Sunday.   Q: Sorry I was not clear enough. How do  I run just the tooShade function but not the rest?  A1: You cannot. A C++ program executes main function always.   Q: Do we need to add test cases to Soundex, even if we got it right the first tiem and did not need additional tests?  A1: Yes. Getting it correct without testing is a mixed achievement.  Rather than count on such forunte next time, please work at establishing a development practice that will go the distance with you :-)   Q: are stacks faster than vectors?  A1: They can be, yes   Q: What is ADT?  A1: live answered   Q: what was ADT again?  A1: live answered   Q: Remind me what an ADT is?  A1: live answered   Q: Thanks! So Chris always runs the whole cpp file whenever he demos it? Why it always only shows the part he is showing us, but not the previous results?  A1: I believe today he had open two different projects and he was switching between them   Q: What does ADT stand for again?  A1: live answered   Q: ADT = Abstract data type?  A1: live answered   Q: Is this idea similar to scope?  A1: Yes, as you enter a new scope, it is akin to pushing a new scope on a stack and when you exit that scope, it is like popping   Q: Is what Chris is talking about right now reflective of the fact that we look at the call stack when we debug?  A1: live answered   Q: does stacks work well with recursion?  A1: You're a bit of ahead of us there, give us a few lectures and we'll get back to you on that one :-)   Q: If you pop a value off a stack, is there a way to push it back on again?  A1: Catch the result and put it back on:  val = stack.pop() and then call stack.push(val)   Q: How would you build a stack from an arry or vector?  A1: Iterate over vector, call stack.push on each element   Q: mosty unrelated, but what do people mean when they say stack overflow  A1: it specifically refers to the function call stack, which has a hard upper limit on the number of function calls you can stack up, and if you exceed that -&gt; stack overflow! (usually crashes program)  A2: we'll cover this next week!   Q: in the above question would val then be stuck as that value? or would it be possible to continually reset the val variable to the value you pop?  A1: I am not sure of the context for this question, can you clarify?   Q: So in python when we did .extend() or .append() was that the same concept of adding to the end? Just trying to see how this relates to what we may have already seen.  A1: Yes, same concept, slightly different vocabulary   Q: this might be silly, but just to clarify:  is a stack more just like a school of thought than a real thing like grid or vector?  A1: Stacks are just as real as grids and vectors! That's why you can see chris using a Stack in the last code example.   Q: Why is main declared to return an int?  A1: main is a special kind of function in C++ that must return an int   Q: why is SPACE in single quotes while other strings are in double quotes?  A1: It is a character, not a string   Q: i guess I'm a bit lost as to why we define it by its behavior rather than the under the hood aspect  A1: This frees up from thinking about the internalls and nitty gritty — we interact with stack as a thing that has simple and well-defined operations, push and pop   Q: dont we need to add characters to make the word  A1: word += c is append each character to word   Q: if you type SPACE as a character does it output as a space, or did he define that somewhere?  A1: It was declared as a constant further up in the code   Q: Isn't the if statement outside the for loop so that it pushes the final word (since there may not be a space at the end of the string)?  A1: You're right that we have a fencepost situation — will need to add the very last word outside the loop   Q: Will the code be updated after lecture?  A1: yes, chris will make the fixes to the code shortly after lecture ends   Q: What if you peek on an empty que or stack?  A1: live answered   Q: My point was that the code looks correct. The if statement needs to be outside just to push the last word to the stack, right?  A1: Yes you are correct (btw, it is hard to relate followup to earlier question when both coming in anonymous, please help me out by using your name if you don't mind)   "
http://cs106b.stanford.edu/lectures/welcome/qa.html
"Lecture 1 Questions and Answers (Exported from Zoom Q&amp;A log)  Q: sound isn't good, it keeps popping  A1: looking into it, thanks!   Q: the sound is better now!  A1: thanks!   Q: sound is better!  A1: cool!   Q: Is all video and audio dosabled for students normally?  A1: yes, this is a property of Zoom webinars.   Q: Sound is still popping frequently  A1: live answered   Q: sound is till popoing :(  A1: live answered   Q: Im not getting any popping at all - sure it's not j students wifi?  A1: live answered   Q: The sound is better on my end as well.  A1: live answered   Q: It isn't popping for me. Maybe the problem isn't with Chris's system.  A1: live answered   Q: people can also increase the audio in their own settings  A1: live answered   Q: sound quality is great on my comp  A1: live answered   Q: my sound is fine!  A1: live answered   Q: Julie's sound is very laggy on my end - not sure if anyone else has that issue  A1: live answered   Q: my sound is also completely fine  A1: live answered   Q: Will we have closed captioning for the lecture  A1: yes, we are currently working on enabling it   Q: still popping on my end, for all speakers. Also, I just had a meeting on google hangouts for work and it was fine (so don't think it's my wifi)   A1: live answered   Q: when do we sign up for sections?  A1: live answered   Q: Sound is great on my end  A1: live answered   Q: no popping   A1: live answered   Q: sound got better for me after using ethernet instead of wifi  A1: live answered   Q: i know we can't send code to section leaders, how will LaIR work online?  A1: You can share your screen with SL over zoom   Q: thank you!  A1: of coruse!   Q: does anyone know the meeting password for the zoom call? (trying to join by phone audio)  A1: 446558   Q: thank you  A1: live answered   Q: What is the abstraction w/ passwords?  A1: The abstraction is hashing! Chris is answering that now   Q: sorry i accidently put my hand up!  A1: no worries!   Q: are there still partners for assignments this quarter?  A1: live answered   Q: can we have partners for the assignments?  A1: live answered   Q: Will the assignments (midterm and final) still be curved?  A1: The focus wil be on formative assessment (qualitative feedback) not summative (quantitive)   Q: Will there be a partner component for assignments as in previous quarters?  A1: live answered   Q: Will letter grades be recorded somewhere in case we need them later for grad school or a letter of rec?  A1: live answered  A2: live answered   Q: Do we have anymore detail on the 'quasi- interview' tests yet?  A1: More details on this will be made availble on the assessments as they are finzlized.   Q: What is the overall percentage required to obtain a Satisfactory grade?  A1: live answered   Q: Are assignments then based on content from the week before they are due?  A1:  A2:  A3: Yes, all content for assignments will be covered the week before the assignment is assigned (generally)   Q: could he clarify on the assignment due time. Does it mean that we all basically have a 12 hr extension on all assignments  A1: live answered   Q: what time is midnight AOE in PST?  A1: 5 am PDT   Q: do we need the textbook?  A1: Recommend but not required.   Q: Just to clarify, what grade would we need to recieve on the assignments to recieve S?  A1: live answered   Q: When are assignments typically released?  A1: out Friday, due a week later   Q: will we have LAIR?  A1: Yes (remote)  A2: More info coming in a later slide   Q: Wait so I am confused on the AoE thing. i am mountain time, are my assignments due at midnight on friday in mountain time for me? or is there some set time according to this AoE thing that corresponds to another time in Mountain?  A1: There is a set time at which assignments are due. This will correspodn to a different time in different time zones. For you in mountain time, I think this translates to 6am.   Q: What will the times for LAIR be? Will it be from 7pm to 11PM?  A1: live answered   Q: will you hold a session for students having trouble installing QT creator?  A1: live answered   Q: Just to make sure, would midnight AoE be Friday, 5am PDT?  A1: yes   Q: will LAIR be exclusively for 106B or for other CS courses as well? will there be extensive waits?  A1: It will be both 106A and 106B   Q: how do we access Ed Discussion? The email I received says to activate my account, but when i click on this link, it says to activate an account with an email and password, but I don't have a password?  A1: email us with a screenshot of the error, we can debug this issue offline   Q: when should we have the QT creater installed? is this on the class page?  A1: instructions here, http://web.stanford.edu/class/cs106b/qt/ you need to have it installed to do assignment 0   Q: thank you!  A1:   Q: Can the same thoery behind the abstractions we learn be used on python?  A1: yes!  Thats exactly why they call it abstraction :-)   Q: Is QT for C++ analogous to what pycharm would be for Python?  A1: correct!   Q: Do we have access to the console.h Stanford-based library?  A1: yes   Q: alright so  i know we are asked to set up qt creator but does sublime text work? or why is qt creator better  A1: Qt Creator has built in debugging and compilation tools that will allow youto build, run and debug your code   Q: If we already downloaded Qt creator a year ago when we thought we were going to take this class, should we delete the program, download OS software update, download newer version of Xcode, and redownload Qt from the website? Or is there a shorter way, such as checking for a Qt Creator update?  A1: It's best to reinstall to get the latest and greatest.  A2: Delete and re-install!   Q: do you use line 3-6 for every program?  A1: Or something fairly similar, yes   Q: Do you have to make an integer to print?  A1: C++ print operation accepts data of different varieties so you can just hand over the integer itself   Q: where did it return 0?  A1: The return value from main() is considered the exit status of the entire program, 0 means it executed successfulyl, aanything non-zero is aan error code   Q: If we took Java, are there any major syntax differences we should be aware of?  A1: We will talk about syntaxt transitions from Java and Python in the next lecture!   Q: Does a C++ function always have to return something? Can it not just print a statement?  A1: No, there are functions that return nothing (void). We will talk about those soon!  A2: A return type of void indicates the function doesn't return a value   Q: I'm getting the error that console.h file not found when writing the Hello World example in qt creator. Is this normal?  A1: You will need the Stanford library in your project — see the blank project on the home page of 106b   Q: How soon after class will the lecture recordings be published on canvas?  A1: however long it takes us to upload the files   Q: Will the smaller meeting also be recorded ?  A1: no   Q: Thank you!  A1:    "
http://cs106b.stanford.edu/lectures/vectors-grids/qa.html
"Lecture 4 Questions and Answers (Exported from Zoom Q&amp;A log)  Q: Will anyone be sticking around after the lecture to answer questions in person?  A1: yes chris will be in this call and there's also the post-lecture zoom meeting that I'll be manning   Q: if the OH are not possible due to timezones, can we still get a debugging session ?  A1: Can you attend any of my/Chris/Nick office hours?  A2: we've also added a 9-11am lair time   Q: where do we find the post lecture meeting  A1: zoom link is in the canvas event for lecture, same place where the webinar link is   Q: Can you also use unsigned int before i to fix the warning issue?  A1: Yes!   Q: why do we have int i=0;i&lt;(int)plainText.length();i++ (why is int in bracket?)  A1: It is a typecast converting the expression to the named type. In this case, it is taking the size_t return from s.length() and converting to plain int   Q: Why is there an (int) in the code being explained  A1: It is a typecast converting the expression to the named type. In this case, it is taking the size_t return from s.length() and converting to plain int   Q: In the for loop  A1: live answered   Q: why does the ceaser cipher for loop has int i=0 instead of size_t i=0?  A1: You could do either, earlier Chris showed code where it was written using size_t, this loop is using int   Q: how is the number converted to a char?  A1: The ascii table assigns each character a number   Q: Can you explain what's going on in that else statement and after?  A1: live answered   Q: can we use functions from Stanford libraries in our assignments?  A1: Yes   Q: so for strings we would opt for toUpperCase?  A1: Yes   Q: so i can only print out char (as an actual letter), and char is a special data type that i can add numbers to and that adds to the equivalent ascii value?  A1: Yes, exactly   Q: could the else statement been moved down one line and put aligned with the if statement??  A1: This particular else goes with the outer if, not the inner.   Q: would the isdigit function work on types like double,long, float?  A1: isdigit works on a single character not a string of characters   Q: if operators compare ascii values how would you compare lengths of strings  A1: if (s.length() &lt; t.length()) …   Q: does it compare every letter or just the first one?  A1: it compares as many characters as needed to establish ordering, this will generally be up through the first character that differs (or if it runs off the end of one string)   Q: is it better to modify strings or create new strings?  A1: Both are reasonable, depends on which better suits the situation   Q: When comparing strings would you first need to check if they are the same length?  A1: No, if string a is a complete prefix of string b,  ithen a is less than b   Q: Does he mean s2 instead of s3?  A1: I believe there are three strings declared in his example, s1, s2, and s3   Q: Can we refer to indexes ithat don't exist in the case of other data structures such as dictionaries in C++ just as we can do in python?  A1: It depends on the data structure what the effect will be. For example, attempting to access the 9th member of. Vector that has only 4 elements will raise an error. Trying to access a non-existent key in a Map will generate create a new empty entry for it   Q: how do hackers exploit a buffer overflow?  A1: there's a whole class on this, cs155! It's a little too complicated to explain concisely unfortunately  A2: Come to my office hours and I'll tell you in person! (but only if you promise not to do evil)   Q: does that compare length or ASCII value  A1: Can you identify what you are referring to by that?   Q: Can you use s.find() to look for a ch instead of string?  A1: yes, the function is overloaded, two versions one that looks for single character, another that looks for substring   Q: could we get an example of s.compare?  A1: string s = apple, t = banana; int result = s.compare(t)  result will be negative, zero, or positive depending on ordering of s to t (less, equal, greater)   Q: yes sorry the compare function Chris just went over  A1: string s = apple, t = banana; int result = s.compare(t)  result will be negative, zero, or positive depending on ordering of s to t (less, equal, greater)   Q: that returns -1, 0 or 1  A1: live answered   Q: Where is the other video on strings?  A1: posted in the same place the lecture videos are posted! Canvas &gt; course Videos   Q: where is the video on strings - I only saw a video on references?  A1: posted in the same place the lecture videos are posted! Canvas &gt; course Videos   Q: Does C++ work like Java where strings with the same characters can still be false when evaluating equality?  A1: No, that is a quirk particular to  Java (about whether equivalent strings evalute as true ==), C++ string equality works as you would expect   Q: when/why do we use references?  A1: To pass a variable with a function and allow the function to make a persistent modification to it   Q: What is the difference between taking in a string by value versus by reference?  A1: If the function changes a string that was passed by reference, the change will be persistentand seen after function completes If the parameter passed by value, any change only exists inside the function   Q: there's 3 t's in b ??  A1: live answered   Q: why isn't it TreeFOOt?  A1: live answered   Q: isnt b just TreeFOOt?  A1: live answered   Q: Isnt there an extra e in the new b value  A1: live answered   Q: does the insert put what you are inserting at the index (thus replacing the previous char at that index), or after that index?  A1: first character of the inserted string will be placed at index   Q: Where did the extra 'e' come from?  A1: live answered   Q: Why is there an e after FOO?  A1: live answered   Q: Shouldn't that be trefooet?  A1: live answered   Q: was there an extra e added by mistake?  A1: live answered   Q: Is there an extra e?  A1: live answered   Q: how did he get an extra e at the end of Tree?  A1: live answered   Q: I think it should be TreFOOet, not TreeFOOet  A1: live answered   Q: why are there 3 'e's?  A1: live answered   Q: There should only be one \"e\" before foot, right?  A1: live answered   Q: Why is the final string TreeFooet and not TreeFoot? Where does the third e come from?  A1: live answered   Q: how can you refer to string a if it's defined in a seperate function?  A1: You generally are not able to access variables outside of the current function.   Q: why is it et at the end?  A1: live answered   Q: Wait is it TreFOOet or TreeFOOet? Does the insert put the FOO in before or after the referenced character?  A1: live answered   Q: cool yeah thx for catching  A1:   Q: Thank you!  A1:   Q: So insert(3,…) will insert the string before the current character at index 3?  A1: Correct.   Q: Does the world at large also have access to the Stanford library?  A1: We publish Stanford library, but it not in common use outside of academia   Q: In the .insert function, is the FOO inserted before or after the third indexed character?  A1: the first characer of the inserted string is place at the index you insert at (in this case index 3)   Q: how do ascii values work for strings? is the ascii value of a string the sum of the ascii values of its characters? or the ascii values put next to one another?  A1: Ascii is defined for single characters, there is not an equivalent for an entire string.   Q: sorry if this has been answered / is obvious, but if I have a helper function that returns a string can I then access that string in say, a main function or something?  A1: Save the return value of function call by assignig to a string variable:  int main() {    string result = myFunction(args);   Q: where can we find the reference video?  A1: The Course videos page of Canvas   Q: Are the two videos (extra preview and mini reference) both mandatory and cover material relevant to the assignment due this week?  A1: live answered   Q: are hashmaps collections  A1: Yes   Q: this doesn't directly relate to the current lecture but is it considered improper form/syntax to subtract from the index within a for loop? as in for(int i = 0, i&lt;x. i++) and then having an i- - for certain cases within the loop  A1: It is unusual and makes the code a little harder to follow, but works just fine   Q: should we watch the additional videos? is it supplemental information or like lecture?  A1: live answered   Q: are vectors arrays?  A1: Vectors are not arrays - there are some key differences between the two that we'll talk about later in the class!   Q: what's the meaning of collection? what is it used for?  A1: Collection means an aggregate type, does not store a single value but many values gathered into one   Q: Do we have the Stanford library by default in Qt?  A1: All of the assignment projects will have the Stanford library avaialble by default   Q: is vec part of the syntax or is that the name of your vector?  A1: It is the variable name   Q: Can we use vectors in both parts or assignment one?  A1: Yes, you will need Vectors in both perfect and soundex   Q: so when we initialize a vector vec, we dont need to set it equal to = {}? we can just type vec; ?  A1: Yes. The default initialization for a Vector creates an empty vector   Q: in terms of memory or efficiency, are there any advantages of a vector of characters versus a string? (of course, we wouldn't have access to all of the built in functions for string)  A1: string is generally more efficient and richer operations/functionality   Q: How do you actually import a Stanford library outside of just assignments for class?  A1: Copy one of our provided project as a starting point   Q: Where do we initialize a vector? is it at the top of our program like in Java?  A1: You can initialize the vector where you declare it   Q: Is there ever a reason to create a vector of chars instead of a string?  A1: Not really   Q: so is collection just like array that in another language (don't remember which tho)?  A1: Yes, arrays, lists, vectors are all the same abstraction   Q: why do you not loop through magic.size() - 1?  A1: The last iteration of the loop is size -1, correct   Q: what does the function size actually do for a vector?  A1: returns the number of elements in the vector   Q: How do str.substr() work when you  want to split a string from the other end of a string?  A1: substr somewhat like python slice, can to pick off prefix, suffix, etc. by how you choose start and stop arguments   Q: do we need to do capital V Vector functionName when declaring a function?&lt;/i&gt;  A1: The typename is capital V Vector in all places where you use the type   Q: Can the data type in the vector only be primitive data types?  A1: You can store any type in Vector, primitives, classes, structs, custom user types, and so on   Q: Wait I may have missed this, but do you need to watch the extra videos to do assignment 1?  A1: live answered   Q: can a vector have characters instead of numbers, and if so then is it still vector or something else?&lt;/i&gt;  A1: yes it can! if you wanted to store characters that would be Vector   Q: like what if I want it to be a list of strings?  A1: Vectors can store alomost any type! So you would declare a Vector   Q: Is there a way to print the vector whole? What would this output look like?  A1: cout « vec « endl;   Q: is vec in the examples like vec[i] a stand in for the actual name of the vector?  A1: The variable was named vec so that is how we later refer to it   Q: for vec[i], where shall we specify the string of concern?   Q: is vec.add() equivalent to append or extend in Python?  A1: Yes   Q: can we do arithmetic with vectors? Like sum, multiply, divide with another vector of same size?  A1: No   Q: Does vec.sort() change the original vector?  A1: yes! it modifies the vector in place and does not return anything   Q: Is there a function or possibly a variable for putting a placeholder inside a vector (eg in matlab, NaN can be used as placeholders inside a vector) ?  A1: No, there is not the notion of a placeholder that fills empty slots   Q: Can you call vec.size() on an empty vector?  A1: Yes, it will return 0   Q: where do we find these other vidoes?  A1: Course videos tab on Canvas   Q: Where can we find the lecture slides again?  A1: course webiste under the lectures tab   Q: Will there always be videos or is that just because we're running behind this week?  A1: live answered   Q: since a string is an array of characters, can i add a character to a string?  A1: Yes   "
http://cs106b.stanford.edu/lectures/c++/qa.html
"Lecture 2 Questions and Answers (Exported from Zoom Q&amp;A log)  Q: What's the name of this song?  A1: Quero Que Tu Va  A2: Quero Que Tu Va by Ananda and Joker Beats!   Q: Thank you  A1:   Q: We're muted automatically right?  A1: yes!   Q: How crucial is it to follow with the textbook or is reviewing the lectures sufficient?  A1: The textbook is a helpful secondary resource, but all the info you need will be presented in lecture   Q: do you mind sharing the password for webinars here? the webinar opens automatically if I click the URL on Canvas but not if I type the meeting ID in  A1: Can you send me an email to remind me about this zelenski@stanford.edu   Q: how does the ACE session differ from CS106L?  A1: See the https://web.stanford.edu/class/cs106b/handouts/course_placement   Q: Will the Qt Installation Session be recorded and posted?  A1: live answered   Q: Are there multiple sections at the same time?  A1: Yes   Q: Will we be proficient in C++ at the end of this course?  A1: Goal is proficiency in classic data structures, algorithsm, good design, but not a deep dive into C++ language itself. If you want that, check out CS106L   Q: are the slides posted online?  A1: Yes, under the lectures tab. For today the slides are here : http://web.stanford.edu/class/cs106b/lectures/c++/   Q: does char work for all strings?  A1: a char is a single character, string is a sequence of characters. In python, a character is more a special case of a length 1 string, but in C++ it is more distinct   Q: What happens if you mix the types? What if I write the following: int a = 'x'  A1: That particular mix is allowed because as Chris said, integer and chars are related behind the scenes. We sometimes say they are in same type family   Q: do you have to put f at the end of float declarations?  A1: No, not necessarily.  (This is an aside, but without the suffix, a constant defaults to being double-width, the f suffix indicates single-width)   Q: can he explain string again?  A1: live answered  A2: live answered   Q: what does the semicolon do? do you need to add that  after every line  A1: C++ uses semicolon as a statement terminator, every statement must end with a semi-colon to be legal syntax   Q: Neat! Thank you.  A1: live answered   Q: Chris is awesome  A1: Agreed!   Q: do floats have an objective limit to how many numbers after a decimal point they can have compared to a double? also, is there ever a considerable storing issue for being more conservative and using doubles as opposed to floats?  A1: Yes, there is! But the details of this are outside the scope of this class. You'll learn more about this in CS107!  A2: It's roughly 6 decimal places for float and twice that for double. Modern practice is to mostly use double for everything, space is cheap!   Q: wait so having int a = 5 and int a = 3 in the same code block renders an error… but having int a = 5 followed by a = 3 does not?  A1: Each new scope (opened by a curly brace) can shadow/replace a name in outer scope   Q: can you redefine a variable as a different type outside of the curly brackets later in the program  A1: Yes, we will talk about scope and different sets of curly braces a little later in this lecture!   Q: after how many decimal points should a number be defined as a double and not a floating point?  A1: It's roughly 6 decimal places for float and twice that for double. Modern practice is to mostly use double for everything, space is cheap!   Q: Can floats and doubles interact? or can you only use floats with floats, etc?  A1: From a high level perspective, they can interact, but really what is going on behind the scenes is that the types are being converted back and forth.   Q: do we need to have all the #'s at the beginning of the code?  A1: The #include is the rough equivalent of import — it is you telling the compiler what libraries your code is using   Q: so is string a defined type?  A1: string is a type defined in the C++ ilbrary  A2: yes, string is a defined type that we are allowed to use becuase of the #include  line at the top of our program   Q: whats the difference between using apostrophes and quotations? ' ' vs    A1: ' ' is used for char type and   is used for strings   Q: Is it allowed to redefine a variable to another type?  A1: generally, once a variable is defined to be of a certain type, it can only store values of that type.   Q: what is the difference between having int before the variable and not having that  A1: live answered   Q: How do I access the Stanford libraries?  A1: they will come packaged together with the starter code for every assignment!   Q: Do we add a semicolon for each line? What if the code does not end on the first line and continues on to the next?  A1: The semi-colon is the what terminates the statement, the whitespace/return/tab dosen't matter to C++ (this is unlike Python)   Q: Can I do addition and subtraction between float and double?  A1: Yes  A2: Yes, and the resulting value will be of type float   Q: I read ahead and the definition of headers isn't entirely clear. Are they simply files that advertise the available public functions and variables of a given c++ file?  A1: Yes, exactly!   Q: whats the point of declaring a variable without setting it to something early on?  A1: Best practice would be to initialize when delcaring, but sometimes you need to do some additional calculation before you can make the assignment   Q: So we should not declare int a at the top of our prgrams and define it later?  A1: generally, you should only define a variable when you need to use it. But yes, you are not allowed to re-define a variable of the same name once you have defined it once   Q: Are there predefined integer values associted with each letter character / special characters?  A1: Yes, it is called the ASCII table.   Q: May be the confusion is because the declaration and initialization happens in the same line as int a= 10  A1: live answered   Q: im pleased at how similar this is to Java thus far  A1: live answered   Q: is there a style preference for typing with spaces (ex. a = 5 vs a=5)?  A1: spaces are preferred because it makes your code more readable!   Q: if you define a statment with int a = 5; and then call a = a string, will it be an error?  A1: yes! once a variable has been defined to be a certain type in C++, it can only store values of that type   Q: is the scope where the } bracket ends?  A1: yes! We will cover this more later in the lecture   Q: Thanks!  A1:   Q: if we can't make the qt installation session, is it pretty straightforward to install?  A1: there are detailed instructions on the course website that you can follow. The session is mostly for debugging any issues that arise.   Q: what does stream mean?  A1: live answered   Q: Why does char a=4 work?  A1: Each letter is assigned a number in the ASCII table.   Q: why are multiple « necessary ?  A1: the &lt;&lt; operastor is used to add together all the individual things you want to output - since we want to output a string and a newline, we have to use two « symbols   Q: why does it use brackets instead of parentheses like a normal function?  A1: I'm not sure I quite follow, can you clarify?   Q: Can you explain the \"stream\" cout again? (what does stream mean)  A1: live answered   Q: Can you print by doing cout &lt;&lt; theAnswer is num. &lt;&lt; endl;  A1: live answered   Q: how does c++ deal with naming variables things like endl?  A1: endl is a reserved name that you're not allowed to use for your variables.   Q: do you recommend using endl instead of \\n?  A1: Yes   Q: Is «endl; always required at the end of printing?  A1: live answered   Q: do we also put semicolons between control flow statements like 'if' or 'for'?  A1: live answered   Q: Can we just run code from Qt to our terminal for our homework/projects or do we have to always download the blankproject in order to have the console work?  A1: You have to use Qt to run all the code for this class - each assignment will have its own starter project that you will download and write code in. Each lecture also has an associated Qt project that you can download and use   Q: whats the difference between endl; and \\n  A1: basically same   Q: is endl equivalent to the new line character in python?  A1: yes   Q: What I meant is why does cout use « instead of (…), like a normal function would?  A1: arguments being output to stream are chained togetherr, the « is acting more like a operator in this case   Q: can we run the all-examples.cpp file? Or we can only edit the code, but not see it runs the result?  A1: Open the project file (named with .pro extension) and then you can build and run the program   Q: why i++?  A1: shorthand for i = i + 1   Q: why do you have to put i++ after the print statement?  A1: live answered   Q: whats the difference between i++ and ++i  A1: pre vs post increment   Q: Does the (i&lt;5) need to be in parantheses?  A1: Yes, it does, the condition in the if or while statement has to be in parentheses   Q: for nested loops syntax do we put another curly bracket within the first?  A1: yes   Q: Does i have to be int for i++? Or does float, double etc work too?  A1: Yes it does   Q: would i += 2 compile?  A1: yes   Q: if you want to increment by more than one, do you add a value after the ++?  A1: live answered   Q: if you are doing a different number than 1 do you still do ++ or do you do like i + 2  A1: live answered   Q: sorry, what does post increment mean? I'm not quite sure what ++i; does  A1: Don't worry for now, both increment I   Q: Would i++ also work in Python?  A1: No, not legal syntax for python   Q: could we also do i = i + 2;  A1: Yes   Q: could you also just say i = i + 2;  A1: Yes   Q: is i=i+1 ok?  A1: yes!   Q: this is very simliar to java! ☺️👍  A1: live answered   Q: what tablet/program/function is chris using to be able to draw on his screen  A1: Wacom table and InkToGo software   Q: Is string defined in the std:: library? It seems I need to do something like  A1: Yes, string is in the std:: namespace.  We will typically do a using namespace std: at the top of our programs so we can use the nickname without the formal name   Q: std::string theAnswer = \"Hello\";  A1: live answered   Q: how is the update statement different from including an update in the body fo the for loop?  A1: It could be same, but by promoting to loop header makes sure you don't forget to have an increment step  A2: either one will work, but typically we include the update step as part of the for loop declaration, since this will automatically cause the update to happen at the end of the loop   Q: Why does the for loop output 0,1,2? does it not do the update statement until after it runs the first time?  A1: Update hapens at botom of loop   Q: are there boolean variables in c++?  A1: yes, type is bool, keywords true and false   Q: those two things are functionally the same, but is one better style wise?  A1: live answered   Q: is there a difference in using an equivalent while/for loop? is it just a style difference or is there a differnece in runtime/efficiency for a more complicated example  A1: live answered   Q: What day of the week are homework assignments due?  A1: always due on fridays, with the late deadline on Sundays   Q: why would we want to start a for loop with i = 0 instead of i = 1?  A1: C programmers start counting from 0, take 107 if you want to learn why   Q: The loop does not go back to intialization statement ever after it starts running,right?  A1: No, first time only  A2: no, this statement only happens once!   Q: Will we have access to the Qt project with the notes after lecture?  A1: Yes, it already posted on the lecture page   Q: Is there 0 indexing in C++ as well?  A1: Yes   Q: instead of cout « can you use print();?  A1: no, there is no defined print() function in C++   Q: Is he referring to global variables vs. local variables?  A1: scope applies to all variables - global variables are just variables that are defined at the top level of {} which means they are available everywhere   Q: Are blocks defined by {}?  A1: yes!   Q: Can you access loopVar inside the for loop?  A1: Yes   Q: How can C++ access updated outsideVar values from inside the block?  A1: The C++ compiler keeps a table mapping names to variables  A2: scope works from outside in - if you define a variable in an outer block, you can access this variable in an inner block defined in that inner block   Q: What if you have an insideVar outside the block, and try to define another one inside the block.  A1: The inner variable will shadow the outer one  A2: you run into the same issue of redefiniing variables as we talked about before   Q: does a new insideVar get created each time the for loop runs? Why is that ok?  A1: The one from previous iteration is no longer needed, so it basically can just re-use it on the next iteration   Q: so just to be clear, a variable that is manipulated within another block, as with outsidevar, will update its value outside of that block? i'm just confused why printing outside var wouldnt still print 5 since it only added within the for loop?  A1: A new scope inherits the outer variables, it does not make copies of them   Q: So in C++, For Loop is more like a function in Python right?  A1: Not quite   Q: if we increment outsideVar inside the for loop, will that be the new value for outsideVar both inside and outside of the loop?  A1: live answered   Q: if a and b are true does it satisfy a l l b  A1: yes!   Q: What actually is ? How is it related to namespaces and are there any alternatives?&lt;/i&gt;  A1:   Q: what about calling variables among different functions?  A1: we'll talk about that on friday!   Q: thank you all! &lt;3  A1:   Q: Can we post the question and answer thread from lecture afterwards?  It is hard to follow while listening to the lecture.   Q: could you confirm this: in a &lt; b : a and b are both doubles, both ints, both floating points, or a mix? whereas in a&amp;&amp; b : a and b are both booleans?   Q: Also, will your example code with comments be posted after lecture?   Q: Will we be going over scoping again on Friday?   Q: Regarding scoping, could we then reassign loopVar outside of the for loop to a different var type and value?   Q: is outsideVar still 5 after the for-loop runs?   "
http://cs106b.stanford.edu/lectures/strings/qa.html
"Lecture 3 Questions and Answers (Exported from Zoom Q&amp;A log)  Q: Nice mandelbrot set!  A1: thank you! You'll likely make one of your own later this quarter!   Q: is this valid in C++?:  a = '9'  int_a = int(a)&lt;/i&gt;  A1: Not sure what you have on second line, the underscore is a space?  A2: It is allowable to convert from integer to character and back, they are in the same type family   Q: trying to define a varible so something like  num = int(a)  A1: The type always goes on the far left and then the name of the variable, e.g.  int a = 45;   Q: do we actually type is true and is false or is this implied by using else?  A1: adding an explicit comparison to true/false is consider redundant, you can just say if (cond) not something like if (cond == true)   Q: In Python, we could often leave out an else statement by having a return both inside the if statement and outside, for instance, since a result would return either way. Can this work in C++, too?  A1: Yes. The else is optional   Q: is the else {} outside the if's curly braces?  A1: Yes, the else has a set of curly braces of its own. These  are the sibling to the braces around the then part   Q: is there a syntactial reason why variables have the first word lowercase and the second uppercase for example firstNum  A1: live answered   Q: For this case, would it be possible for both x and y to be equal to 5?  A1: Yes, that is possible i(although in this code fragement y is 7 not 5)   Q: for boolean operators, what is the default order of operations? like does not go before and/or?  A1: order of precedence in not, then and, then or.  You can alwyays use explicit parenthesis to be sure that you are getting the order you intend   Q: What about constants in C++?  A1: still all caps!   Q: (In terms of the naming convention)  A1:   Q: do we always have to use using namespace std;?  A1: By convention, we will do this, it allows us to use the features defined in the standard namespace by referring to them by their short name, withotut the full namesapce qualifier, e.g. string instead of std::string   Q: also is int main() the same as public static void in java  A1: yep, good eye!   Q: Where does the 0 in main get returned to? And what happnes to it&gt;  A1: live answered   Q: What is a double?  A1: A type that can hold decimal value (with fractional component)   Q: Why do you have to return an int in main()? Why not void main()?  A1: live answered   Q: why would you return 0?  A1: live answered   Q: what should the returnType be if the function doesn't return anything?  A1: void   Q: must you always return 0 in main  A1: live answered   Q: Do you still have to return 0 in main in updated versions of C++?  A1: live answered   Q: The outcome of main() is not int. Why we declare mainType as int?  A1: live answered   Q: what is the meaning of namespace std;  A1: By convention, all our programs start with the statement using namespace::std;  This allows the program to use the features defined in the standard namespace by referring to them by their short name, withotut the full namesapce qualifier, e.g. string instead of std::string   Q: Is there a reason why you chose to return 0 in the above function and return 1 in this function?  A1: returning 0 from main means all good, whereas retunring 1 means something went wrong   Q: when testing code, is there a way to simply run a new function outside of main. eg could we run factorial(5) to debug?  A1: As a general case, no, a C program always starts from main.   Q: whats the difference between using return and cout «»  A1: cout is printing the result, i.e. equivalent to calling python print() function   Q: so are all operator= statements valid? e.g %=, *= along with += and -=?  A1: Yes   Q: and do we always need return?  A1: chris is answering this now!   Q: Is main always an int?  A1: live answered   Q: Do you always have to define the output of a fucntion before the name of the function as is in int factorial Or can we just write the funtion name and then have it return a string or an int or another type all togther?  A1: Always need to declare first (Chris is talking about this right now!)   Q: couldnt you set the main variable type to be a string and have the return be something like 'good'?  A1: The main() function is special and has to return integer  type always. Other functions don't have that restriction   Q: What if our purpose of the main function was to return a sentence (string), how do we handle that?  A1: You won't be able to do this with main() because it is special and always has to return an integer type rseult. Other functions can return strings or other type   Q: What's the difference between:  [returnType functionName…] and [int functionName…]?  A1: int is just a specific value of returnType that we can use.   Q: for the for loop inside factorial, does the first iteration not include n—?  A1: The advance step (third piece of for loop) executes at the bottom of each loop iteration,   Q: do you have to declare the function before actually writing the code in it?  A1: Yes   Q: are there public v private specifications for functions in C++ like there are in Java?  A1: Yes, but visibility is only a feature of certain kinds of functions (member functions they are called)   Q: what is the benefit of using void functions?  A1: live answered   Q: I opened up Qt Creator to see whether I could try typing along with Chris. Will there be an introduction to what the various project types are, or how to set up and execute projects from scratch?  A1: There is a blank project linked to course home page — grab it!   Q: basically when do you want to return a type and when do you want to return a void  A1: live answered   Q: wait so just to be clear the void function will not output c?  A1: Agreed. To print something, there needs to be an explicit use of cout « value   Q: What is the double data type - how is it different from and int/float  A1: It is a higher-precision variant of float.   Q: for the function printTenTimes  A1: live answered   Q: What's the point of calling a function if you don't want to return a value?  A1: live answered   Q: for the printTenTimes function what does the cout outside the for loop do?  A1: It prints the final newline after the all iterations of the loop have executed.   Q: but  couldnt you set the value produced by a void function anyway  A1: A void function does not produce a value, there is nothing you receive when calling it   Q: why would you ever declare the function name without writing the code within?  A1: It serves as description of the function that introduces it to other clients (so they know how many, what type of parameters, etc)   Q: when you say you can define functions earlier than when you write the code for them what does that mean?  A1: When you write the declaration you are indicating the intention for the function — how many arguments and what type and what it returns. This serves to introduce the function to other clients.  Later you follow through to implement the function to make good on your intention   Q: got it thanks  A1: live answered   Q: so you could declare a function using double functionName, char functionName, etc?  A1: A declaration includes the function return type, the function name, and then the type and order of arguments in parentheses   Q: Is there a way for us to have access to the Q&amp;A after lecture?  A1: yes, we're workin on exporting it somewhere on the course website   Q: is this like a lambda function?  A1: Not exactly… That maybe is a question to bring to helper hours, cause it's kind of subtle to explain   Q: When you say cout &lt;&lt; myValue why/how does the computer know to print 5 rather than literally myValue  A1: If we put the character myValue within double-quotes, it would understand that we want it to literally print those exact letters. Without double quotes, the name of a variable evaluates to the value of that variable   Q: Why do the main functions in these two examples have no return?  A1: the function named main() has int return type in all of these examples   Q: Why would you pass by value rather than just use a global variable?  A1: Global variables are frowned upon as poor style.  It is considered better to be explicit about what information is being transferred into/out of a function call, for which parameters are the right mechanism   Q: What's the reason for doing this? Is it just better style?  A1: I lost track of what this question is in reference to, sorry. Can you provide more context?   Q: by doubleValue do we mean doubleValueWithRef?  A1: No, there are two different functions and they behave differently. Review the code in slides to see what is different, one is pass by value the other by reference   Q: stylistically, any preference for passing by reference placement of &amp;? For example void funct(int&amp; a); or void funct(int &amp;a);  A1: Be consistent, but either is fine. I tend to attach to the type myself   Q: why didn't the main function return 0 in that last example?  A1: oops!  oversight :-) Sharp eyes, thank you!   Q: In the doublevalue example why does the main() have no return 0?  A1: Oversight. oops! Sharp eyes, thank you   Q: Shouldn't the function doubleValue(myValue) in main be doubleValueWithRef(myValue)?  A1: fixed, thank you!   Q: but so if i defined int example = 15, then called doubleValueRef(example), that would work?  A1: Yes, this works, but not the constant number (as you noted)   Q: i just cannot put 15 directly  A1: Right   Q: so if you did \"x = 5; doubleValueWithRef(x);\" then x will be 10?  A1: Yes!   Q: great thanks  A1:   Q: is main function the same as if name == main in python?  A1: Yes, effectively   Q: wait but if i can define functions in the main why would i use header files in the first place mate?  A1: You can also write functions in a separate file than the one where main is   Q: so header files are mainly to declare functions we have not written yet?  A1: yes, as well as to advertise the functions to other clients   Q: how different is #pragma once is different from  #ifndef HEADER #def HEADER .. .. .. #endif&lt;/i&gt;  A1: #pragma once is the modern way to do double include guard   Q: when does the first pset go out?  A1: Tomorrow (Saturday)   Q: Sorry, I may have missed if you said it, but does a string have an escape  character at the end automatically?  A1: Escape? Do you mean newline or something else?  C (not C++) has a convention of ending a string with a null (0) character, but C++ strings internally handle that  A2: sorry, i meant null character like C. you answered it. thanks!   Q: Are there empty strings? But not empty characters, right?  A1: Effectively yes (I am being a little cagey cause there is a zero character to be pedantic about it)   Q: is the function at in the string library?  A1: yes   Q: What was the .at for?  A1: s.at(3) is mostly same thing as s[3]. but whereas at does bounds-checking for safety the square bracktes does not do that error checking (for efficiency reasons)   Q: sorry, i meant null character like C. you answered it. thanks!  A1:   Q: Does .length have to be defined or does the library take care of that?  A1: .length is defined as part of the standard string type   Q: is .length interchangeable with.size in c++?  A1: In some situations, but not all   Q: is count « endl just separating the outputs therre  A1: Yes   Q: is stanfordTree.length() equal to 13 or 12?  A1: live answered   Q: to get for(char c: stanford_tree) to work, is there an iterator defined in strings header file??  A1: Yes   Q: Are we going to pick up on this lecture on Monday or should we watch the string video before Monday's class?  A1: live answered   Q: Do you call all functions on strings with that  syntax? Why wouldn't it be length(stanford tree)  A1: live answered   Q: Does the cout«endl; at the end of each for loop just create that extra vertical space when printing the function?  A1: live answered   Q: is there a way to find the index of a character in a string?  A1: Look at find function for string type   Q: does slicing in strings work the same as in python?  A1: live answered   Q: how the null character is handled in c++ strings as we always null terminate in c  A1: live answered   Q: my kind of happy hour!   Q: Will you guys be switching off lecturing each week ?   Q: thank you guys so much!   Q: Can you please go over references and the use of references again?   Q: Do you need to define variable type when calling index numbers?  A1: live answered   Q: could you explain where the 0 in main get returned to again? and why you have to do this? do you have tor return 0 in void  functions?   Q: :( too bad   Q: May you please explain (what using namespace std;) does?   Q: going back to the void function, so void functions can print but can't return?   Q: does the cout« endl; after each for loop create that extra vertical space when printing on the screen?   Q: Will we go over strings again next week?   Q: Can you post examples files on the website so can play with them.   Q: is there a difference between int *a vs int &amp;a while pass by reference ??   Q: So does the int functionName(int&amp; x) basically pre create a variable that gets passed into the code that follows? So you don't have to write it again insided the function?   Q: Is it considered bad style to use std::string?   Q: what language is used as the industry standard?   Q: Thank you   Q: Thank you!   "
http://cs106b.stanford.edu/qt/recommended-settings.html
"Below are our suggested configuration settings for Qt Creator. You are not required to adopt these settings, but we recommend them for a more pleasant experience.  Access the settings for Qt Creator from the top menu bar:     on Windows or Linux, menu item is Tools -&gt; Options…   on Mac, menu item is Qt Creator -&gt; Preferences…   Build &amp; Run settings  We recommend checking the following boxes:          Save all files before build      This saves your code files before you compile or run your project.           Compile Output: Open pane when building      Display information about the compilation process when your project is being built.           Application Output: Open pane on output when running always      Display your program's output in a pane at the bottom of window. Normally you can see the output in the popup graphical console and don't need this bottom pane, but if your window crashes, the bottom output can be helpful to figure out what went wrong.           Application Output: Clear old output on a new run      This clears out previous output from the output pane.      Debugger settings          Debugger font size follows main editor      This will make your debugger font size grow if the main text editor font size is enlarged.           Switch to previous mode on debugger exit      This closes unneeded debugger panes when the debugger is no longer running.      Analyzer settings  Qt Creator has a feature called the \"Clang Code Model\" that highlights errors and gives code warnings as you type. Neat! However, the feature is a bit too picky, and it spits out a lot of warnings about code that is just fine. To make the feature a bit less picky, we'll change its default flags and settings to more closely match the CS 106B/X style guide.  In Qt Creator's preferences, go to the Analyzer area, then in the initial Clang Tools tab, find the area labeled \"Diagnostic Configuration\", and click \"Manage…\" Now a \"Diagnostic Configurations\" window will pop up with several entries in it. Click \"Copy…\" This will pop up a small window asking for your configuration's name. Name your new configuration something like \"CS 106BX settings\" and press Enter. You should now see your configuration in the Diagnostic Configurations list. Make sure it is selected.  Now, below, under the \"Clang\" tab, replace the existing text with this text:  -Wall -Wextra -Wcast-align -Wfloat-equal -Wformat=2 -Wlogical-op -Wno-missing-field-initializers -Wno-old-style-cast -Wno-sign-compare -Wno-sign-conversion -Wno-write-strings -Wreturn-type -Werror=return-type -Werror=uninitialized -Wunreachable-code -Wno-keyword-macro -Wno-reserved-id-macro -Wno-unused-const-variable   Then click OK. Now the unwanted warnings should go away.  If your project still isn't using the new settings, in the left bar of Qt Creator, click \"Projects\", then click \"Clang Code Model\", then at right, change the drop-down from \"Global\" to \"Custom\", and choose your \"CS 106BX settings\" from the list.  If you ever decide that you want to turn off the Code Model feature entirely, in Qt Creator click: Help -&gt; About Plugins … -&gt; C++, then uncheck \"ClangCodeModel\". "
http://cs106b.stanford.edu/schedule
"This is a preview of the schedule planned for the quarter. We will update this schedule as we go.  Keep in mind that this page should faithfully describe the past, but it won't always accurately predict the future.  Assignment due dates are expressed as end of day \"AoE\" (Anywhere on Earth). Your planning is likely simplest if you treat the deadline as end of day in your local time zone, but the final cutoff is end of day in UTC-12.  Lectures will be delivered via zoom MWF 2:30-3:20pm PST. You're encouraged to join us live if possible. We will also post the recording for later asynchronous viewing. You can access the lecture zoom room and recordings from our course Canvas page.              &nbsp;     Mon     Wed     Fri     Section/Assign                                                                                                                           1                            Apr 6         📓Welcome!                                Apr 8         📓C++                                Apr 10         📓Strings                                               &nbsp;                 &nbsp;                           Assign0:       Welcome to CS106B!    due  Apr 10 (AoE)                                                                                                   2                            Apr 13         📓Vectors and Grids                                Apr 15         📓Stacks and Queues                                Apr 17         📓Sets and Maps                                                      Section1:       ADTs                    &nbsp;                           Assign1:       Getting Your C++ Legs    due  Apr 17 (AoE)                                                                                                   3                            Apr 20         Big O                                Apr 22         Functional recursion                                Apr 24         Fractals                                               &nbsp;                 &nbsp;                           Assign2:       Fun with Collections    due  Apr 25 (AoE)                                                                                                   4                            Apr 27         Procedural recursion                                Apr 29         Exhaustive recursion                                May 1         Recursive backtracking                                               &nbsp;                 &nbsp;                    &nbsp;                                                                                                  5                            May 4         C++ Classes                                May 6         Dynamic arrays                                May 8         Heaps                                               &nbsp;                 &nbsp;                    &nbsp;                                                                                                  6                            May 11         Sorting and searching                                May 13         Algorithm analysis                                May 15         Memory &amp; pointers                                               &nbsp;                 &nbsp;                    &nbsp;                                                                                                  7                            May 18         Linked data structures                                May 20         Linked lists                                May 22         List algorithms                                               &nbsp;                 &nbsp;                    &nbsp;                                                                                                  8                            May 25         Memorial Day Holiday                                May 27         Trees                                May 29         Binary search trees                                               &nbsp;                 &nbsp;                    &nbsp;                                                                                                  9                            Jun 1         Huffman coding                                Jun 3         Hashing                                Jun 5         Graphs                                               &nbsp;                 &nbsp;                    &nbsp;                                                                                                  10                            Jun 8         Dawg                                Jun 10         Wrap                                Jun 12                                                        &nbsp;                 &nbsp;                    &nbsp;                                      "
http://cs106b.stanford.edu/assignments/assign2/searchengine.html
"  Search engines are one of the most influential developments of the modern Internet age, having completely revolutionized the way that people use and interact with the Web. What was once an intractable jumble of data with no semblance of organization has been transformed into an easily searchable repository of human information, For this assignment task, you will recreate this phenomenal technological development by using the Map and Set ADTs to build a document search engine that can find matching pages for a user's query on demand with lighting-fast response time. This is a simplified version of the technology underpinning Spotlight, Google, Bing, and every other modern search engine that you encounter in your day-to-day internet use.  Want to see the power of search right at your finger tips? Use the \"Search\" feature in the top-right of the website and search for the phrase \"easter egg\" and see what you instantly find hidden deep in the recesses of the course website…  Big picture The program you write for this assignment task will produce a custom data structure for a particular set of web pages, represented in the form of a URL (\"Uniform Resource Locator\") and an associated string of text representing the body of the webpage. First, your program will process the body text of each page, and will populate the data structure with a mapping from words in the body text to page URLs.  Once you have built the data structure, you will then write a function that enables search, given the data structure of webpage information and a target query that one might want to search for. Finally, you will write a console program that enables a user to enter many different search queries and get back the webpages on which those search queries can be found. Put all together this way, you will have built your own mini search engine!  An inverted index  The key to enabling efficient search of a large data structure comes down to how we structure and store the data. A poor choice in data structures can cause search to be very slow, while a wise arrangement can allow search to be near instantaneous. In this section of the handout, we will describe one data storage scheme that can be used to enable super-fast lookup.  To begin with, let's consider the index of a book. For example, when you look in the index of the CS 106B textbook, one of the entries is the keyword \"Internet\", and two page numbers, 18 and 821. The word internet occurs on page number 18 and again on page number 821. A book's index is an example of an inverted index, where you have a word in mind, and you can find the page number it is listed on (a book's index does not usually include every instance of the word on all pages, but is usually curated to give you the best matches). In other words, an inverted index creates a mapping from content to locations in a document (or table, etc.). This in contrast to a forward index, which for our book example would be a list of page numbers with all the words listed on that page. A search engine uses an inverted index to allow for fast retrieval of web pages - thus, we will first figure out how to build one of these inverted indexes to efficiently store the data that we want to be able to search through.  Efficiency note: To create an inverted index, you must process the entire document, or set of documents, and catalog where each word is located. This may not be a fast process, but once the inverted index is complete, searching for words and their corresponding locations is extremely fast.  Milestone 1: Building the inverted index  Given that we love decomposition in CS106B, we will break down building the index into a couple different steps.  Your first main task will be to complete the following function, whose declaration has been provided for you in search.cpp.  Map&lt;string, Set&lt;string&gt;&gt; readDocs(string dbfile)   This function should opens the named file, reads it line by line, and builds a map from a URL to a Set&lt;string&gt; representing the unique words contained on that page.  We gathered the body text from each of the pages in the course web site and organized it into a combined database file for your program to process. The format of the database file is very simple:    File format            The lines of the file are grouped in pairs.                    The first line of a pair is a page URL.           The second line of a pair is the body text of that page, with all newlines removed (basically text of the page in a single string).                       The third and fourth lines form another pair, the fifth and sixth another, ad so on, with alternating lines of page URL and page content.           To process the database file, your code will need to:     For each page URL, tokenize its contents - in other words, divide the body text into individual tokens, which will be separated by spaces. Do this division using the stringSplit function from  strlib.h.   Discard any non-word tokens. A word (or at least \"word-like\") is a token that contains at least one letter.   Trim away leading and trailing punctuation marks (according to ispunct) from each token.  Specifically this means to remove any punctuation characters from the beginning and end of a token, but not from inside a token. The input tokens section and section. and \"section\" are each trimmed to become the same token, which makes searching more effective. It also means that doesn't should be stored as-is, (and likewise for as-is), since for both of these words, the punctuation occurs in the middle of the word.            (As an aside, this sounds similar to the functions you wrote for last week's assignment so you may have some code you can repurpose. The trim task makes a tidy helper function that you can unit-test independently. Decomposition is always a good idea to aid your test and debug efforts.)           All words should be stored in lowercase format, to make for easier search eventually.   Note: Even if the body text contains a thousand occurrences of the word \"llama\", the set of unique tokens contains only one copy, so gathering the unique words in a set is perfect for avoiding unnecessary duplication.  Given the following sample file (found in res/tiny.txt), www.shoppinglist.com EGGS! milk fish        bread cheese www.rainbow.org red ~green~ orange yellow blue indigo violet www.dr.seuss.net One fish Two fish Red fish Blue fish !!! www.bigbadwolf.com I'm not trying to eat you  your function should return the following map: {     \"www.bigbadwolf.com\" : {\"eat\", \"i'm\", \"not\", \"to\", \"trying\", \"you\"},     \"www.dr.seuss.net\" : { \"blue\", \"fish\", \"one\", \"red\", \"two\"},     \"www.rainbow.org\" : { \"blue\", \"green\", \"indigo\", \"orange\", \"red\", \"violet\", \"yellow\"},     \"www.shoppinglist.com\" :{ \"bread\", \"cheese\", \"eggs\", \"fish\", \"milk\"} }   We've provided some unit tests for this function. Make sure all the provided tests pass and extend with student tests to be sure the coverage is fully comprehensive. Don't move on until all tests pass.  Now that we have the document data in a well-structured form, it is time to build our inverted index! Your next task is to complete the following function, defined in search.cpp.  Map&lt;string, Set&lt;string&gt;&gt; buildIndex(Map&lt;string, Set&lt;string&gt;&gt;&amp; docs)   Given the map of document data, your job is to build the inverted index data structure, which maps each word to a set of URLs where that word can be found. Before starting to implement this function, take some time to work through the example map shown above.    Q7: What would the sample inverted index for the above document map look like?   Once you've worked through this example, go ahead and implement the function. Make sure to follow the typical cycle of testing and debugging your code. We've provided unit tests for this function. Make sure all the provided tests pass and extend with student tests to be sure the coverage is fully comprehensive. Don't move on until all tests pass.  Compound queries  Now that we have built an inverted index, we can turn our focus to figuring out how to give users the ability to query our database and get search results back!  Milestone 2: Compiling website matches based on user query  For this part of the assignment, you will be implementing the following function, provided in search.cpp.  Set&lt;string&gt; findQueryMatches(Map&lt;string, Set&lt;string&gt;&gt;&amp; index, string query)   The query string argument can either be a single search term or a compound sequence of multiple terms. A search term is a single word, and a sequence of terms is multiple consecutive words, each of which (besides the first one) may or may not be preceded by a modifier like + or - (see below for details).  When finding the matches for a given query, you should follow these rules:    For a single search term, the search matches are the URLs of the webpages that contain the specified term.   A sequence of terms is handled as a compound query, where the matches from the individual terms are synthesized into one combined result.   By default, the matches are added across search terms. However, the user can apply a modifier to a search term to change how its matches are aggregated into the result.            If the user prefaces a search term with +, then matches for this term are intersected with the results.       If the user prefaces a search term with -, then matches for this term are removed from the result.           Here are some example queries and how they are interpreted    quokka            matches all pages containing the term \"quokka\"           simple cheap            means simple OR cheap       matches pages that contain either \"simple\" or \"cheap\" or both           tasty +healthy            means tasty AND healthy       matches pages that contain both \"tasty\" and \"healthy\"           tasty -mushrooms            means tasty WITHOUT mushrooms       matches pages that contain \"tasty\" but do not contain \"mushrooms\"           tasty -mushrooms simple +cheap            means tasty WITHOUT mushrooms OR simple AND cheap       matches pages that match (((\"tasty\" without \"mushrooms\") or \"simple\") and \"cheap\")           There is no precedence for the operators, the query is simply processed from left to right. The matches for the first term are combined with matches for second, then combined with matches for third term and so on. In the last query shown above, the matches for tasty are first filtered to remove all pages containing mushrooms, then unioned with all matches for simple and lastly intersected with all matches for cheap.  In implementing this logic, you will find the Set operators for union, intersection, and difference to be very handy!  We've provided some unit tests for this function. Make sure all the provided tests pass and extend with student tests to be sure the coverage is fully comprehensive. Don't move on until all tests pass.  Putting it all together  So far, we've built capability to turn a mass of unstructured text data into a highly-organized and quickly-searchable inverted index, as well as written code that allows us to find matches in this database given specific user queries. Now, let's put it all together and build our own search engine!  Milestone 3: Building a search engine!  Your final task will be to implement the function below, whose definition has been provided in search.cpp.  void searchEngine(string dbfile)   This function should implement a console program that should implement the following logic:    Using functions you have already written, construct an inverted index from the contents of the specified file.   Display to the user how many website URLs were processed to build the index and how many distinct words were found across all website content.   Once you have the index constructed, your program should go into a loop that allows the user to enter queries that your program will evaluate.   Given a user query, you should calculate the appropriate matches from the inverted index.   Once you have computed the resulting set of matching URLs, you should print it to the screen.   Repeat this process until the user enters the empty string (\"\") as their query. At this point, your program should stop running.   After you have completed this function, you should be able to the following interaction flow with the user.  Example program run: Stand by while building index... Indexed 50 pages containing 5926 unique terms  Enter query sentence (RETURN/ENTER to quit): llama Found 1 matching pages  {\"http://cs106b.stanford.edu/assignments/assign2/searchengine.html\"}  Enter query sentence (RETURN/ENTER to quit): suitable +kits Found 2 matching pages  {\"http://cs106b.stanford.edu/assignments/assign2/searchengine.html\", \"http://cs106b.stanford.edu/qt/troubleshooting.html\"}  Enter query sentence (RETURN/ENTER to quit): mac linux -windows Found 3 matching pages  {\"http://cs106b.stanford.edu/lectures/sets-maps/qa.html\", \"http://cs106b.stanford.edu/qt/install-linux.html\", \"http://cs106b.stanford.edu/qt/install-mac.html\"}  Enter query sentence (RETURN/ENTER to quit): as-is wow! Found 3 matching pages  {\"http://cs106b.stanford.edu/about_assignments\", \"http://cs106b.stanford.edu/assignments/assign1/soundex.html\", \"http://cs106b.stanford.edu/assignments/assign2/searchengine.html\"}    Congratulations! You're well on your way to becoming the next Internet search  pioneer! 🔍  Notes    You should use the Stanford library's stringSplit function for tokenizing the text and parsing the user's query sentence.   The Map and Set classes are the right data structures for storing the inverted index itself.  Sets are especially handy when evaluating the query sentence because of the awesome high-level set operations that combine sets.   Searching should be case-insensitive, that is, a search for \"binky\" should return the same results as \"Binky\" or \"BINKY\". Be sure to consider what implications this has for how you create and search the index.   The res subfolder of the starter project includes are two provided database files. tiny.txt is the small example used in the writeup and website.txt is the body text extracted from all of the pages in our course website (as of April 17). These are text files that you can view the contents of these files in Qt Creator if desired. The project resource files are listed under Other files -&gt; res. Your program can open a resource file by specifying the path to open as \"res/myfilename\".   References    Inverted Index on GeeksForGeeks   Wikipedia article on Inverted Indexes   Stanford Natural Processing Group on Tokenization   Extension ideas  If you get done with the main portion of the assignment and have some extra time, we would encourage you to try working on an extension! A non-exhaustive list of potential extensions is listed below:     Weights            When you get the results from a Google search, they are ranked so that the more relevant results are first on the list. The Google algorithm is a well-kept trade secret (though it was originally the Page Rank algorithm, named for its creator, (then) Stanford Master's student Larry Page), but a simple idea is to put results that have the most matches inside a page highest in the ranking. For this extension, you would need to re-think how you create your index, to include the number of matches.           Phrase search            The assignment does not allow a search for multi-word terms, such as \"section leader\". Searching for phrases is not trivial, as you cannot simply keep a mapping of all possible phrases in the document. You could, however, keep track of where in each document a word is, and then use that information to determine if words in a phrase are next to each other in any particular document.           Stop Words            The English language has many, many words that show up in text but are not particularly important for content, such as \"the\", \"and\", \"if\", \"a\", etc. These words are called Stop Words, and it would make your index smaller if you removed a set of stop words from the index. You can find out more about stop words here.           Stemming            For your current index, if a user searches for \"section\" they won't find matches for \"sections\", even though pages that talk about sections might be relevant and a good match. Stemming is the process of reducing words to their base form, so that (for example) both \"section\" and \"sections\" would become, simply, \"section\".           If you have other creative ideas for extensions, run them by the course staff and we'd be happy to give you guidance! "
http://cs106b.stanford.edu/assignments/assign1/soundex.html
"     Census Day is April 1, 2020. If you live in the US and haven't yet responded, take action to be counted! 🖐🏼🖐🏽🖐🏿🖐🏻🖐   This exercise is all about C++ string processing, with a little bit of file reading and use of the Vector data structure. For this part of the assignment, you will be writing code and making changes in soundex.cpp, as well as answering some short answer questions in short_answer.txt.  Name lookup One of the more pesky features of the English language is the lack of consistency between phonetics and spelling. Matching surnames is a particularly vexing problem because many common surnames come in a variety of spellings and those variations continue to evolve through time and distance. Cultural differences and input errors can produce to a different spelling than a user's expectations. Traditional string matching focuses on exact matches or partial/overlap match; these algorithms do not adapt well to the messy real-life situation.  Wouldn't it be great if you address an email to your instructor without having to figure out which vowels go where? (Is it \"Zelenski\" or \"Zalinsky\" or \"Szielinski\" … um, how about I just email Chris?) Read on…  Phonetic match Classifying names by their phonetic structure is the goal of the Soundex system, patented by Margaret O'Dell and Robert C. Russell in 1918. The US Census is a big consumer of Soundex along with genealogical researchers, directory assistance, and background investigators.  Soundex is a coded index based on the way a name sounds rather than the way it is spelled. Surnames that sound the same, but are spelled differently, like \"Vaska\", \"Vasque\" and \"Vussky\", have the same code and are filed together.  The algorithm is designed with English pronunciation in mind and this simple algorithm does a surprisingly good job. There are some counter-examples, even in English, where it gets tripped up, but nonetheless, the US census has extensively used a variation on the Soundex algorithm for almost a century!  A Soundex code A Soundex code is a four-character string in the form of an initial letter followed by three digits, such as Z452. The initial letter is the first letter of the surname and the three digits are drawn from the sounds within the surname using the following algorithm:     Discard all non-letter characters from surname: dashes, spaces, apostrophes and so on.   Save the first letter of surname, convert to uppercase if necessary.        Encode each letter as a digit using the table below.                                 Digit           represents the letters                             0           A E I O U H W Y                             1           B F P V                             2           C G J K Q S X Z                             3           D T                             4           L                             5           M N                             6           R                           Coalesce adjacent duplicate digits from code (e.g. 222025 becomes 2025).   Replace the first digit of code with the saved uppercase letter.   Remove all zeros from code.   Make code exactly length 4 by padding with zeros or truncating the excess.   To ensure you understand the construction, get a piece of scratch paper and manually compute a few names, such as \"Zelenski\" (Z452) and \"Gregg\" (G620).    Q10: What is the Soundex code for \"Bowman\"? What about for your own surname?   Search program The program you are to write allows the user to perform a Soundex search on a database of surnames. The operation of the program is to:     Read a database of surnames from a text file.            This step is provided for you in the starter code.  The \"database\" is simply a Vector&lt;string&gt;.           Prompt the user to enter a surname.            The function getLine from \"simpio.h\" will be helpful here.           Compute the Soundex code of the surname.   Iterate over the database, compute Soundex of each, and gather a vector of those surnames with a matching code.   Print the matches in sorted order.            The Vector has a handy sort() operation, e.g. vec.sort(), and you can print a vector using the &lt;&lt; operator, e.g. cout &lt;&lt; vec &lt;&lt; endl;           Repeat steps 2-5 until user indicates they are done.   Here is the output from a sample run of the program:  Read file res/surnames.txt, 26409 names found.  Enter a surname (RETURN to quit): Zelenski Soundex code is Z452 Matches from database: {\"Zelenski\", \"Zelnick\", \"Zelnik\", \"Zelnis\", \"Zielonka\"}  Enter a surname (RETURN to quit): troccoli Soundex code is T624 Matches from database: {\"Therkelsen\", \"Torkelson\", \"Trakul\", \"Traxler\", \"Trisal\", \"Troccoli\", \"Trockel\", \"Troxel\", \"Troxell\", \"Trujillo\", \"Turkel\"}  Enter a surname (RETURN to quit):  All done!   Strategies for success Decompose the problem Your best strategy for approaching a large undertaking such as a complete program is to decompose the problem into smaller, more manageable tasks and proceed step by step, testing as you go.     Q11: Before you get started writing code, take some time to brainstorm your decomposition strategy for this problem. Briefly describe your strategy in short_answer.txt.   To get you started, we're going to walk you through what it might look like to decompose and implement the first step of the Soundex algorithm.  The first thing that you might want to do is to write a function to generate a Soundex code. A single function that attempted the entire computation would be unwieldy but if you instead break it down into smaller string processing tasks, you can develop those small helper functions one at time and write and test each individually.  For example, Step 1 of the Soundex algorithm corresponds to a helper function to remove non-letters from the string. The C++ library has a function isalpha that reports whether a character is alphabetic and the string operation erase can be used to discard characters from the middle of a string. Putting those two together, we have this starting point (provided for you in soundex.cpp):  // WARNIING: Code is buggy! Use unit tests to identify which inputs are mishandled void removeNonLetters(string&amp; s) {     for (int i = 0; i &lt; s.length(); i++) {         if (!isalpha(s[i])) {             s.erase(i, 1);         }     } }   Test as you go With an implementation of removeNonLetters drafted, the next step is to test it. We provided a few unit tests to get you started. if you run these provided tests against the given function, you will see that the tests all pass. From this, you might conclude that the function is good to go. But there is a problem lurking within the code that will reveal itself if you push it harder.  Review our provided test cases to see what sorts of inputs we tested, and, more importantly, what sorts of inputs we didn't test.  Brainstorm what those missing cases are and then add them.  Think about edge cases that could lurk in the extremes or cases that are uniquely distinguished from the provided tests. As a hint, notice that all of the provided test cases have exactly one non-letter in the input. Add your own tests that target inputs at the extremes or otherwise unusual, such as input that is completely empty or composed of only non-letters. You should add at least 1 new test to expose the bug in the given implementation of removeNonLetters.  Your goal in writing tests is to enumerate a comprehensive set of tests that shine your \"flashlight of truth\" into the shadows and brings any problems into the light so you can debug and fix them. Good tests are the key to writing robust software. A great developer is not only a great coder, but also a great tester.  Debug a failing test case Once you have added a failing test case that fails, use the debugger to get more information about how the function has gone wrong. Set a breakpoint within code block for your test case. A good place to stop is on the line with the operation that you want to trace through, like so:    Now run the tests under the debugger. When you hit the breakpoint, you can single step through through the call toremoveNonLetters while watching in the variables pane to observe the changing state of your variables. This \"step and watch\" approach is the same as you used in the Assignment 0 debugging tutorial.  From this point, you should be able to find the bug and fix it - go ahead and do that!  Continuing on Once you've fixed the bug from above, you have a working helper function to complete the first step of the Soundex algorithm. You're now set up to follow a similar process to complete the rest of the assignment:    Pick a small task or part of the algorithm to implement.   Define a new helper function to accomplish that task.   Write some tests that define the expected behavior of this new helper function.   Fill in the code for your helper function, debugging as you go. Continue writing code and debugging until you have passed all the tests from the previous step.   Rinse and repeat.   Your end goal is to pass all of the top-level Soundex tests that we've provided for you in the starter code. Once you pass all these tests, you've got a working implementation of the Soundex algorithm! Make sure to add a couple additional high-level Soundex tests as well, in addition to the tests that you're writing for your decomposed functions. Finally, the last step is to implement the soundexSearch function described above. Once you can replicate the example program flow correctly, you're done with the assignment!  Useful resources    C++ Standard Library Documentation   Stanford C++ Library Documentation   Textbook   Testing    Testing is key here. Make sure that you take advantage of the SimpleTest testing framework!   If a test is failing, put a breakpoint inside the failing test, and step through the code line by line using the debugger. Keep an eye on the variables pane - that will be your most helpful resource to figure out what is going wrong!   The starter project includes a text file res/surnames.txt containing the surnames of Stanford students, faculty, and staff for the use of Soundex search. There are some 26,000 unique surnames within the Stanford community, wow! For early testing, you may want to change the program to read names from the file res/small.txt instead which contains a tiny set of names that is easier to debug on.   Soundex specification details    Soundex does not distinguish case in the input; letters can be lower, upper, or mixed case. The first character in the result code is always in upper case.   C++ string/char, library advice    Make sure to take advantage of the concat, replace, erase, etc. string functions. Also you may find the functions available in \"strlib.h\" useful as well.   For case conversions, you can either use the functions in &lt;cctype&gt; if you are operating on a char variable or in \"strlib.h\" if you are operating on the string datatype.   Remember that C++ treats individual characters differently than strings. Individual characters have type char. To talk about a specific single character, you must use single quotes (e.g. 'a' rather than \"a\"). Strings have type string. To talk about a specific string, you must use double-quotes (e.g. \"hello\" rather than 'hello').   In a similar vein, the integer 5 is a distinct beast from the digit character '5' or the string \"5\". Take care to express the type carefully to match you intentions.   References    https://www.archives.gov/research/census/soundex   Online calculator http://www.eogn.com/soundex/   Extension ideas  If you get done with the main portion of the assignment and have some extra time, we would encourage you to try working on an extension! There are lots of other phonetic systems out there besides Soundex. Here is a nonextensive list:    Daitch-Mokotoff   Beider-Morse   Metaphone   New York State Identification and Intelligence System Try implementing one of these other systems and see if you can get better or more intuitive surname matches! We recommend adding new files to the project to implement your extension. When submitting extensions on Paperless, make sure to make a separate submission for your extension code, so that it doesn't interfere with the main functionality of the Soundex system. If you have other creative ides for extensions, run them by the course staff and we'd be happy to give you guidance!  "
http://cs106b.stanford.edu/submit_checklist
"Written by Sam Redmond and Keith Schwarz  This handy checklist is designed to help make sure your code is fully ready to go before you submit it. Before you send it in for, take a few minutes to work through this checklist.  Functionality          ✅ I've double-checked the assignment handout and made sure that what my code does matches what it's expected to do.           ✅ I've reviewed my code one line at a time. I understand each line of code I've written, why it's there, and why it's necessary.      Test cases          ✅ I've run all of the provided test cases against my code and resolved any test failures.           ✅ I've supplemented the provided test cases with tests of my own. For each part of the assignment, I've written at least one test case to make sure it works well in the common case.           ✅ For each part of the assignment, I've thought of at least one edge case that could cause problems and designed a test case for it. (And ideally, I've done this for multiple edge cases!)      Style          ✅ I've read the CS106B Style Guide at least once in its entirety and asked questions to my section leader about any parts I don't understand.           ✅ Each of my functions, conceptually, performs a single task.           ✅ The dense parts of my code are commented, and those comments describe what the code accomplishes rather than merely restating the logic in plain English.           ✅ Every function I've written has a comment preceding it that explains what the function does, what its parameters are, and what its return value (if any) means.           ✅ I've updated the comments at the top of each of the files I've edited with an explanation about what the code in that file does and anything unusual that a reader should keep an eye out for.           ✅ For each container class I've used (Vector, Map, etc.), I can justify why I chose that particular container type rather than another container type.           ✅ The code I've written does not use any global variables.           ✅ The code I've written does not use the goto keyword.           ✅ All of my variables and functions clear and descriptive names.      Final Submission          ✅ I've auto-indented my code in Qt Creator.           ✅ I've handled all the TODOs in the code and removed any comments from the starter files describing what I need to do.           ✅ I've removed all cout statements left in the code that I used for debugging purposes.           ✅ I've removed all commented-out blocks of code that are no longer necessary.           ✅ I've read the Submit\" section of the assignment handout and confirmed that I'm submitting all of the required files.     "
http://cs106b.stanford.edu/handouts/syllabus.html
"   Hi there 👋 and welcome to CS106B!   CS106B Programming Abstractions is the second course in our introductory programming sequence. The prerequisite CS106A establishes a solid foundation in programming methodology and problem-solving in Python. With that under your belt, CS106B will acquaint you with the C++ programming language and introduce advanced programming techniques such as recursion, algorithm analysis, data abstraction, explore classic data structures and algorithms, and give you practice applying these tools to solving complex problems.  We're excited to share this great material with you and have a superb team of section leaders that will support you through the challenges to come. We hope you will find the time worth your investment and that you enjoy your growing mastery of the art of programming!  Teaching Team                       Lecturer: Chris Gregg ✉️cgregg@stanford.edu                         Lecturer: Julie Zelenski ✉️zelenski@stanford.edu                         Head TA: Nick Bowman ✉️nbowman@stanford.edu       Our wonderful undergraduate section leaders.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Lectures Lectures this quarter will take place on Monday, Wednesday, and Friday from 2:30 - 3:20 pm PDT (GMT -7).  All lectures will be available live on Zoom, as well as recorded for download or viewing later. In order to protect course security and integrity, all Zoom information for lecture will be posted on Canvas, via the lecture calendar event.  Read more about lecture, including how to find the appropriate Zoom information.  Sections In addition to lecture, you'll also attend (via Zoom) a weekly small-group discussion section. Read more about section here.  Prerequisites The prerequisite for CS106B is solid performance in CS106A and readiness to move on to advanced programming topics. A comparable introductory programming course (including high school AP courses) is often a reasonable substitute for our CS106A. If unsure if this course is the right for you, read more about course placement.  Units CS106B is offered for 3 to 5 units. If you are an undergraduate student, you must enroll in CS106B for 5 units (this is by department and university policy, no exceptions). Matriculated graduate students may enroll for 3 or 4 units to squeeze into a limited tuition allowance, however this is solely a bookkeeping change and has no effect on the course requirements.  Textbook Roberts, Eric. Programming Abstractions in C++. ISBN 978-0133454840.  Ensure that you either own or have access to a copy. Recommended readings for each lecture will be posted on our lecture calendar.  Read more about the textbook.  Software The official CS106 programming environment is Qt Creator, which is an editor bundled with C++ compiler and libraries.  The software runs on Windows, Mac, and Linux.  The Qt Installation Guide has instructions for installing the tools onto your computer.  Getting help We want to enable everyone to succeed in this course and offer different paths to help.  The instructor and head TA will hold office hours (Zoom). The course helpers and section leaders staff regular LaIR helper hours (Zoom).  The CS106B Ed Discussion forum allows public Q&amp;A and discussion with your peers. Here is the Quick Start Guide to using Ed. Please participate!  Accommodations Students who need an academic accommodation based on the impact of a disability should initiate a request with the Office of Accessible Education. Professional staff will evaluate the request with required documentation, recommend reasonable accommodations, and prepare an Accommodation Letter dated in the current quarter. Students should contact the OAE as soon as possible since timely notice is needed to coordinate accommodations. The OAE has contact information on their web page http://oae.stanford.edu.  Assignments Our schedule plans for one assignment per week. Depending on the week's topics, the accompanying assignment may consist of written problems, hands-on exercises with the tools, targeting coding tasks, and/or a larger complete program. All assignments are done on an individual basis.  Programs will be graded on \"functionality\" (is the program's behavior correct?) and \"style\" (is the code well written and cleanly designed?).  We use a bucket grading scale to focus attention on the quantitative rather that quantitative feedback.  The grading on your assignment is discussed a one-on-one session with your section leader, with an emphasis on providing targeted feedback for individual improvement. Read more about assignments.  Assessments There will be a mid-quarter and final assessment, though neither will be a traditional exam. We will have more information on the format as we figure it out ourselves. Read more about assessments.  Course grades Per university directive, all courses in Spring 2020 will use a Satisfactory / No Credit grading scheme. The impetus for this is a recognition that our students are learning in very different contexts. A silver lining of this policy is that it allows us to focus on the good stuff: the joy of learning, mastery of an important skill, and less on the minutiae of grading. We are going to be just as serious about teaching and getting you high quality feedback.  Our goal for you is to leave the course with mastery of the material and a solid foundation for further study in computer science. We think your enhanced coding superpowers are much greater reward than any letter grade could be.  Course grades will be calculated using the following component weightings:     Assignments 55%   Mid-quarter assessment 15%   Final Assessment 20%   Section Participation 10%   To receive a satisfactory grade, we expect satisfactory work on each component. This means you are required to make a real effort on and submit all the assignments, take the assessments, and attend/participate in section. But, importantly, skipping some portion of the class because you think you don't need it to pass the class is taken as an indication of lacking mastery of the material and can lead to a non-passing grade. We want you to engage with all the material in the class, not aim to do the minimal amount that you think might be required for passing. Please take this to heart when doing the work for this class  Incompletes The university \"I\" grade (\"incomplete\") is appropriate for circumstances of significant personal or family emergency disruption that prevent a student from finishing course requirements on schedule.  To be considered for an incomplete, you must have completed all of the assignments up til now at a passing level and must have an extenuating circumstance which warrants an extension of time beyond the end of the quarter. Approval for an incomplete is at the instructor's discretion. Incompletes are not considered for reasons such as low performance or to ease your schedule.  Honor Code The Stanford Honor Code is an undertaking of the students and faculty to individually and collectively participate in upholding the highest standards for academic integrity.  Please review our Honor Code handout for a thorough explanation of how it applies in this course. Your programs should be your own original, independent effort and must not be based on, guided by, or jointly developed with the work of others.  The vast majority of you are here to learn and will do honest work for an honest grade. We celebrate and honor your commitment.  Because it's important that all cases of academic dishonesty are identified for the sake of those playing by the rules, we reserve the right to use software tools to compare your submissions against those of all other current and past students and will refer all cases of concern to the Office of Community Standards. "
http://cs106b.stanford.edu/testing
"Why testing? Anybody that writes code for some purpose (whether as a researcher, a software engineer, or in any other profession) will get to the point where others are relying on their code. Bugs in software can be dangerous or even deadly. Additionally, users do not enjoy using software that is buggy and crashes and fixing bugs once the software is in production is very costly. Most importantly, good engineers take pride in building things that work well and are robust.  The key to writing working software is developing good tests. In this course we follow an approach called test-driven development. As you write code, you will also write companion tests. These tests are used to verify that the code you just finished writing works as intended.  This strategy is sometimes called \"test-as-you-go\". You work in small steps, being sure to test thoroughly, and only move on after you having confirmed the correctness and fixed all issues. The beauty of this approach is that each step is relatively straightforward and easy to debug. Imagine the opposite approach: you write hundreds of lines of code, the code does not work, and now you need to figure out which one of those hundreds of lines of code isn't working as expected! That is the sort of frustration that we want to help you all avoid as you continue to develop your skills as programmers.  SimpleTest For CS106B, we provide a unit-test framework called SimpleTest that you will use to test your code. This framework was pioneered by our ace colleague Keith Schwarz. SimpleTest provides a simple, clean approach to writing and running test cases.  Here is an example of how you might see the SimpleTest framework used in the starter code of an assignment.  // reversed(str) returns copy of str with characters in reverse order. string reversed(string s) {     string result;     for (int i = s.length() - 1; i &gt;= 0; i--) {         result += s[i];     }     return result; }  /* * * * * * Test Cases * * * * * */  PROVIDED_TEST(\"Demonstrate different SimpleTest use case\") {     EXPECT_EQUAL(reversed(\"but\"), \"tub\");     EXPECT_EQUAL(reversed(\"stanford\"), \"drofnats\"); }   When we provide tests for you in the starter code, each test case is wrapped in the special macro PROVIDED_TEST. The string argument in parentheses describes the purpose of the test and the code block that follows (enclosed in curly braces) defines the actual test behavior.  EXPECT_EQUAL Within the code block, the test macro most commonly used is EXPECT_EQUAL which confirms the two arguments are equal. A typical use case for EXPECT_EQUAL is to take a value produced by your code, e.g. the return value from a call to one of your functions, and confirm that value matches to the expected outcome. For example, in the above code, EXPECT_EQUAL is used to compare the result of the call reversed(\"but\") to the string \"tub\". If the two are indeed equal, the test passes. If they do not match, the test is reported as a failure.  When you add your own test cases, you will wrap your test code blocks in the STUDENT_TEST macro instead. The STUDENT_TEST functionality and structure is exactly the same as PROVIDED_TEST, it simply distinguishes the tests you've written yourself from those we provide for the benefit of your grader. For example, after adding your own tests to the above file, it could look something like this: // reversed(str) returns copy of str with characters in reverse order. string reversed(string s) {     string result;     for (int i = s.length() - 1; i &gt;= 0; i--) {         result += s[i];     }     return result; }  /* * * * * * Test Cases * * * * * */  PROVIDED_TEST(\"Demonstrate different SimpleTest use case\") {     EXPECT_EQUAL(reversed(\"but\"), \"tub\");     EXPECT_EQUAL(reversed(\"stanford\"), \"drofnats\"); }  STUDENT_TEST(\"test additional cases not covered by the provided tests\") {     EXPECT_EQUAL(reversed(\"racecar\"), \"racecar\");     EXPECT_EQUAL(reversed(\"\"), \"\");     EXPECT_EQUAL(reversed(\"123456789\"), \"987654321\"); }     Important note: You should never modify the provided tests - these are the same tests that will be used for grading, so it is not in your best interest to modify them. If you want to test different scenarios, always add new tests using the STUDENT_TEST macro.   EXPECT Another test macro that is regularly used is the EXPECT which confirms the truth of a single expression. If the expression evaluates to true, the test passes. If false, it reports a test failure. For example, if you added the isPalindrome function to the above program, you could add a test case that uses EXPECT to confirm the correct result from isPalidrome, as shown below.  // reversed(str) returns copy of str with characters in reverse order. string reversed(string s) {     string result;     for (int i = s.length() - 1; i &gt;= 0; i--) {         result += s[i];     }     return result; }  bool isPalindrome(string s) {     return s == reversed(s); }  /* * * * * * Test Cases * * * * * */  PROVIDED_TEST(\"Demonstrate different SimpleTest use case\") {     EXPECT_EQUAL(reversed(\"but\"), \"tub\");     EXPECT_EQUAL(reversed(\"stanford\"), \"drofnats\"); }  STUDENT_TEST(\"test additional cases not covered by the provided tests\") {     EXPECT_EQUAL(reversed(\"racecar\"), \"racecar\");     EXPECT_EQUAL(reversed(\"\"), \"\");     EXPECT_EQUAL(reversed(\"123456789\"), \"987654321\"); }  STUDENT_TEST(\"test my isPalindrome function\") {     EXPECT(isPalindrome(\"racecar\"));     EXPECT(!isPalindrome(\"stanford\")); }   When would you use EXPECT instead of EXPECT_EQUAL?   EXPECT_EQUAL which is appropriate for any situation in which you have two values that can be compared for equality (two numbers, two strings, two Vectors, etc.).  EXPECT allows you to express a wider variety of conditions beyond simple equality. For example, you could confirm the truth of a complex set of conditions by passing a compound expression such as EXPECT(x &gt; y &amp;&amp; y != z || y == 0);  EXPECT_ERROR You pass an expression to EXPECT_ERROR and it evaluates the expression  and observes whether it calls the error() function to report an error. If an error is raised, this causes the test to pass.  If not, it causes the test to fail and reports that the expression failed to trigger an error. EXPECT_ERROR is used in the very specific situation of confirming expected handling of errors within your code.  REPORT_FAILURE The REPORT_FAILURE macro allows you to customize the error message used to report a test failure rather than produce the default test failure message. IT may be useful in situations where the default message does not provide enough information for you to be able to diagnose the failure.  runSimpleTests The main program of every project will be configured so that you have three choices every time you want to run your program: run all the tests, run a selected portion of the tests, or run no tests at all and proceed with normal execution of the program. The way that you can control this is demonstrated below: int main() {     if (runSimpleTests( &lt;test choice argument&gt; ))         return 0;     ...  }   The argument to runSimpleTests is either:     NO_TESTS (skip testing altogether, just run normal main function)   ALL_TESTS (run all tests for all files)   SELECTED_TESTS (provide menu for user to select which file to run tests)   Debugging a failing test The goal you are shooting for is for all of your tests to pass. However, if you get a failed test result, don't look at this as sad times, this test result is news you can use. The failing test case indicates that you have identified a specific operation that behaves counter to your expectations. This means you know where to focus your attention.  Dig into that test case under the debugger to analyze how it has gone astray. Set a breakpoint inside the text code block, choose to stop at the line that is at or before the failing EXPECT/EXPECT_EQUAL statement.    Now run the tests under the debugger. When the program stops at the breakpoint, single step through the code while watching in the variables pane to observe the changing state of your variables, using a technique just like you did in the Assignment 0 debugging tutorial.  After you understand the failure and apply a fix, run that test again. When you see the test now pass, you can celebrate having squashed that bug!  Test-driven development  We highly recommend employing test-driven development when working on your assignments. To do so, follow these steps:     identify a small, concrete task (bug to fix, feature to add, desired change in behavior)   construct tests for the desired outcome, add them to the file in which you're currently working, and verify the current code fails these tests   modify your code, using effective debugging strategies, to complete the task you identified   re-run your newly added tests and verify they now succeed   test the rest of the system (by running all tests) to verify you didn't inadvertently break something else   You change only a small amount of code at once and validate your results with carefully constructed tests before and after. This keeps your development process moving forward while ensuring you have a functional program at each step!  Test cases and grading  The SimpleTest framework will be supplied with each assignment, and there will be some initial test cases provided in the starter project, but you will also be expected to add your own tests.  You will submit your tests along with the code and the grader's review will consider the quality of your tests.  We will also provide comments on your tests to help you improve your testing approach. Please incorporate our feedback into future assignments; it will improve your grade, and more importantly, your effectiveness as a programmer. We guarantee future employers will appreciate your ability to write good tests and well-tested code!  Here are some things we look for in good tests.          Are the tests comprehensive? Is all the functionality tested?           Where possible, are the tests self-contained and independent?           Did you anticipate potential problems, tricky cases, on boundary conditions?           Did you develop the tests in a good order? Did you test basic functionality before more advanced functionality? Did you take small, carefully chosen steps?      Common questions  Should each EXPECT/EXPECT_EQUAL be in a STUDENT_TEST code block of its own or can I list several within one code block?  For tests that are closely related, it may be convenient to group them together in the same code block under one test name. The tests will operate as one combined group and show up in the report as one aggregate success (if all pass) or one failure (if at least one fails).  However, there are advantages to separating each individual test case into its own code block. You will be able to choose a clear, specific name for this block. The separation isolates each test so you can easily identify exactly which cases are passing and which are failing. For example if you have  STUDENT_TEST(\"lots of tests all together\"){     EXPECT(... test 1 ...)     EXPECT(... test 2 ...)     EXPECT(... test 3 ...) }   then if test 2 fails, test 3 will never run and you won't be able to see the output - you won't know if test 3 passed or failed. On the other hand, if you structure your tests like this  STUDENT_TEST(\"test1\"){     EXPECT(... test 1 ...) }  STUDENT_TEST(\"test 2\"){     EXPECT(... test 2 ...) }  STUDENT_TEST(\"test 3\"){     EXPECT(... test 3 ...) }  then all the tests will run individually, and even if test 2 fails, you will still get information about test 3. Having this sort of isolated behavior might make debugging any problems you encounter a little bit easier!  What happens if running a bogus or malformed test case? A test case confirms what you asked it to, in literal fashion. If you ask it to confirm a bogus outcome, then any result of such a test will be erroneous. For example, consider this test case that confirms that \"ball\" is a palindrome (which is a bogus proposition)  STUDENT_TEST(\"ball is a palindrome\"){     EXPECT(isPalindrome(\"ball\")) }   If the test case itself is bogus, it is like asking the wrong question and thus any answer to that question is equally bogus. A buggy version of isPalindrome that returns true for ball would \"pass\" this case. A correct version that returns false would report as a test failure.  These results are exactly backward the truth. This is very misleading!  Each test case should be constructed such that a correct program passes it. Your goal is to make your program pass all tests. Go go go, go for green!.  "
http://cs106b.stanford.edu/resources/textbook.html
"  The CS106B textbook is Roberts, Eric S. Programming Abstractions in C++ ,  ISBN 978-0133454840.  The book was written by Stanford CS professor Eric Roberts and targeted directly for this course. Readings from the textbook are suggested to accompany lecture.  Section problems and programming homework will not be assigned directly out of the textbook and it possible to succeed in the course without it.  However, we think you will appreciate it as a supplement to the presentation of the material in lecture and section. It also contains a wealth of practice problems for self-study.  The book is stocked by the Stanford Bookstore or can be ordered online from various retailers. There are copies on reserve in the engineering library.  In previous quarters, a preliminary \"course reader\" version of the textbook was distributed as as PDF, linked below. Note the Beta PDF is missing some of the content and polish of the final textbook, but might be sufficient for your needs.  📗CS106B/X Course Reader, Beta 2012  "
http://cs106b.stanford.edu/qt/troubleshooting.html
"    This page contains a large list of common issues students have had when setting up and using Qt Creator. Consider searching this page using Ctrl+F (Command+F on Mac) to jump quickly to the text matching the error message or issue you are having.      How to \"re-initialize\" a Qt Creator project    A large number of Qt Creator ills can be resolved by following these steps to re-initialize your project. (Please note that this requires deleting some files from your project. Be careful not to delete your assignment solution code. Make frequent backups of your files.)         Quit Qt Creator.     Navigate to the folder where your project is stored. Delete the file with the extension .pro.user, such as Life.pro.user Take care: Delete only the file with exactly the pro.user extension , not the other files such as the Life.pro (screenshot)     Also delete the \"build\" folder for your project. This is located in the parent directory of your project's directory, and has a long name like build-Life-Desktop_Qt_5_x_x_kit_xxbit-Debug. Delete the entire build directory. (screenshot)     Re-start Qt Creator. Choose menu item \"File\" -&gt; \"Open File or Project…\", navigate to your project folder and open its .pro file. Qt should ask you to \"Configure Project\", just as if you were opening for the first time.     Now try to build and run to see if things work any better.      Installation woes    I installed Qt Creator previously. Must I reinstall or can I use my existing installation?   You should install the latest. Our projects are written to work with the latest version and the most recent fixes. Look in the Qt Creator menu for \"About Qt Creator\" to confirm what version you are running. The latest version as of April 7 is Qt Creator 4.11.2 Based on Qt 5.14.2. Be sure your version number is equal or greater; otherwise re-install Qt.   When I open a new project, the \"Configure Project\" options are empty. Error: No kits available.   A \"kit\" is a C++ compiler. If no kits are available, your Qt installation may be missing essential components. When installing Qt, you must select the appropriate component (e.g. MinGW or macOS) for your platform, as specified in our installation instructions. If you fail/forget to select this component, the observed symptom is \"no kits available\". To fix this, you'll need to reinstall Qt Creator. Delete your existing Qt folder and repeat the steps in our install guide.   When I open a new project, the \"Configure Project\" options are all grayed out. Error: No suitable kits found.   On MacOS, be sure you have followed the XCode steps in our install instructions. After downloading XCode you must run it once in order for the necessary components to be installed.   Double-click installer on macOS fails to open. Error: Cannot verify the identity of the developer.   Instead of double-clicking the file, right-click and choose Open.   Opening a project    Opening my project on the campus cluster computers crashes Qt Creator.   Qt Creator does not play nice when the project files are stored on the network AFS server. In particular, your Downloads directory is a bad place to store a project. Instead try copy the files to your U: drive or the local E: drive.   I double-click a .cpp file to open it in Qt Creator and the \"Build\" and \"Run\" buttons are grayed out.   Double-clicking a .cpp file opens only that single file. You instead want to open the entire project by double-clicking the .pro file.   I can't tell which file is the .pro file because Windows File Explorer is not displaying filename extensions.   If your File Explorer is set to hide extensions, the file sample-project.pro will display the name sample-project.  You can configure for extensions to be displayed in File Explorer by choosing menu item File-&gt;Options, select the \"View\" tab and under Advanced settings, uncheck \"Hide extensions for known file types\".  Click \"Apply\" button.   Build warnings and errors    Build warnings: I get tons of yellow warning flags all over my code, including for code in the library that I did not write myself.   Recent versions of Qt Creator have added a feature called a \"code model\" that performs style checking on your code as you write it. This is sometimes useful, but we think the checker is too picky and gives warnings about code that is not dangerous. You can safely ignore these unnecessary warnings. If you'd like to make the warnings go away, change the Analyzer to our Qt Creator Recommended Settings.   Build error: Build progress meter is solid red, QFileSystemEngine::currentPath: getcwd() failed   On macOS, this error indicates that Qt Creator was prevented from accessing the project files because the application lacks the needed privileges. In order to build a project, Qt Creator needs to be able to read and write files. You can grant Qt Creator access by agreeing when you get an alert such as this one:  You can also go to \"System Preferences\" -&gt; \"Security &amp; Privacy\" -&gt; \"Privacy\" tab -&gt; \"Files and Folders\" to review and change what access has been granted to individual applications.   Build error: symbol(s) not found for architecture x86_64    This means that your code calls a function that was never defined. This could indicate there is a typo in the function name or mismatch in the number or type of parameters. To get more information, click on the Compile Output tab near the bottom of the screen, and look through the output to find the name of the  function(s) that is undefined so you know where to look to find the error.    Build error: Duplicate symbol for architecture x86_64   This indicates you have two or more definitions of the same function. Each function should have one and only definition. To get more information about the error, click on the Compile Output tab near the bottom of the screen and look through the output to find the name of the duplicate function(s). This could mean you mistakenly copy/pasted the definition twice or you added the same file to the project more than once.  If the problem is the latter, your best bet is to re-initialize the project to reset all files.   Build error: xcopy command invalid number of parameters   There are certain applications that conflict with Qt Creator. A few applications we know are problematic are:             Cygwin       Git / GitHub       Rtools       Strawberry Perl       Windows Services for Unix           The applications install files (most notably a program called sh.exe) that confuse Qt Creator. If you have any of the above programs installed, your best bet is to uninstall them or to use a machine that does not have that software installed.      Sometimes you can modify the application so that it will not conflict with Qt Creator, by removing or renaming the offending files. For example, if you have git installed, you can use your file explorer to go to Git's usr/bin subdirectory (default is C:\\Program Files\\Git\\usr\\bin) and rename the file sh.exe to sh2.exe.      Build error: Terse, cryptic message in Issues tab, e.g. Error   What is reported in the Issues tab may be terse and/or unhelpful. Instead click the bottom Compile Output tab to view more detailed information about the build activity. Use these additional details to further diagnose the problem.   Build error: Generic build error, e.g. Error 1 or Error 2 or copyResources Error 4   Be sure to check in the Compile Output tab for additional details that might further diagnose the problem.      One common cause of generic build errors is having stored your project in a directory whose name includes certain disallowed punctuation or international characters (e.g. Chinese, Korean, etc.)  Try moving your project into a simple folder name containing only English characters, and then re-initialize your project.      Permission problems    Build failed. Error: cannot open output file ...\\MyProgram.exe: Permission denied.        This error means that your executable is still running from the last time you ran/tested the program a moment ago. Shut down any running instances of your program. You might need to open your operating system's Task Manager to stop them all.      Cannot delete, rename, or modify my program .exe file or build folder. Error: You'll need to provide administrator permission to delete this folder.         A Windows feature called \"System Protection\" can lock your .exe programs so that they cannot be modified. You can disable this feature in your system settings. Go to Control Panel, and choose System. Now click the System Protection tab/link, which is either on the left or top side of the window. Depending on your version of Windows, either click the \"Disable system protection\" radio button, or if you instead see a list of disk drives, double-click on the drive where your project is stored (likely drive C:), and change the setting to Off.        Another thing that can cause the \"permission denied\" problem is anti-virus software. In particular, McAfee Anti-Virus places strong locks on all .exe files that prevents you from modifying or deleting them. You may need to disable or uninstall McAfee to make this behavior go away.      Program execution errors    My program abruptly halts during execution. Error: Runtime Error or Application has unexpectedly quit or Runtime terminated in an unusual way   This means the program has \"crashed\" or exited due to an error during execution. This generally means the program has a bug that attempts an illegal operation or causes an exception to be thrown. Clicking the Application Output tab might provide some additional information.      The best way to proceed on diagnosing an execution error is to use the debugger. Instead of clicking the plain green triangle \"Play\" to run your program, click the green triangle with a bug on it. This runs your program under the debugger. When your program encounters the error which caused the problem, your program will stop in the debugger and show you where in your code the crash occurred.      The Assignment 0 debugger tutorial introduces simple use of the debugger.      What else?     I have an error not listed in this FAQ. What else can I try?   About 90% of random Qt Creator issues we've seen can be resolved by \"re-initializing\" your project. Follow the re-initialize steps.   Help!  It still doesn't work! If you had read through the list of known fixes and were not able to resolve your issue, we will try our best to help you figure it out. Drop into helper hours and show us the problem over Zoom. Or you can contact us via forum/email to get help. In your email/post, be sure to include the following information:     Your operating system and version number (Windows 10, Mac OS X 10.15, Fedora Linux 17, etc.)   The Qt version information from \"About Qt Creator\"   Which step in the process has failed (be specific)   Specific error message            Please include the exact text via copy/paste and/or a screenshot.       For a build error, be sure to grab the detailed information from the  Compile Output tab.           Thanks, and good luck!  You can do it! "
http://cs106b.stanford.edu/upcoming
"Upcoming events    Loading...               "
http://cs106b.stanford.edu/qt/using-qt.html
"Opening a project Each Qt Creator project includes a file named with a .pro extension.  To open a project in Qt Creator, you may either:     Double-click the .pro file in the Finder/File Explorer.   In the Qt Creator application, choose menu File-&gt;Open File or Project,  navigate to the project folder and choose the .pro file to open.   Note that opening a source file (i.e. life.cpp) opens that single file. Instead you want to open the pro file (life.pro) to get access to the entire project.  The Qt Creator window Below is a screenshot of a project open in Qt Creator.    View options The icons in the upper part of leftmost edge are the \"View\" options. A project opens in \"Edit\" view and the main pane of the window is used for editing your source files. Another view you will often use is the \"Debug\" view, which using the main pane of the window for the debugger controls.  Project pane is to the right of the View options. It display a hierarchical listing of the project files. The file currently selected for editing is highlighted. Your code files for the project are listed in the Headers-&gt;src folder and the Sources-&gt;src folder. The files in the lib/StanfordCPPLib folders are the code files for the Stanford Library which includes classes like Vector, Grid, and Map.  Build-run controls are in the lower left. Click the hammer icon to build the program.  If the project successfully builds, click the play button (plain green triangle) to run the program. To run the program under the debugger, click the debug button which is the green triangle with a bug on it.  Output pane tabs are along the bottom edge. At the bottom of the window, there are named tabs for \"Issues\", \"Application Output\", and \"Compiler Output\".  Click one of these tabs to show the corresponding information in the lower pane. Sometimes the explanations in the \"Issues\" pane are too terse to be helpful. In these cases, looking at the \"Compile Output\" or \"Application Output\" panes will provide more verbose and possibly helpful additional details.  Qt debugger  Check out the debugger tutorial from Assignment 0. "
http://cs106b.stanford.edu/assignments/assign2/warmup.html
"  Throughout this course, you will strengthen your programming chops by writing a lot of C++ code. Having effective strategies for testing and debugging this code is a huge help when solving challenging programs along the way.  Knowing your way around the debugger is key, so let's get cracking on learning how to make good use of it!  \"How I got better at debugging\" from Julia Evans  This exercise demonstrates use of the debugger and unit tests on the ADT types.  In this page, there are a few highlighted questions you are to write answers for in the file short_answer.txt. These answers are the only deliverable from the warmup, you do not need to write or submit warmup code.  1) Observe ADTs in debugger  Start by looking over the provided code. The program has three simple ADTs functions. We also provided some companion unit tests to help you find and diagnose the bugs that lurk within.  The reverse function operates correctly. It uses a Stack to reverse the contents of a Queue. Run tests on adtwarmup.cpp and you'll see that this function passes its tests. We will use this function as practice for examining ADTs in the debugger.  Set a breakpoint within the reverse function and run the program in Debug mode.  When the debugger stops at your breakpoint, the Variables pane in the upper-right of debugger window shows the variables in scope and their values. You should see the value of val, and the variables q and s. A nice feature of the Qt Creator debugger is that it can display the internal contents of a collection. Expand q to find a data member named _elements and expand that to see the current queue elements. Do the same for s.  The contents of a collection look something like the following screenshot:    Once you have both the stack and queue expanded, step line-by-line using the Step Over button. As you step, watch the top-right pane and observe elements being added and removed.  On some systems the debugger labels elements with indexes from [0] to [size-1], but remember these ADTs do not allow access to elements by index. Step to the half-way point (after the first while loop has completed but before the second while loop has begun) and look at the contents of s and q.  Answer these questions in short_answer.txt:     Q1. Is the first queue element displayed in debugger pane (element [0]) the element at front of queue or the back?  Is the first stack element displayed on the top of stack or the bottom?   2) Test stutterNegative  Testing and debugging are closely related. After writing a piece of code, you will want to test it to verify its behavior. If you uncover a problem, you run your test case under the debugger to further diagnose the bug.  The function stutterNegative is a variant of the stutter problem from last week's section. stutterNegative is intended to modify a Queue&lt;int&gt; to double each negative number, i.e. turning the queue {3, -5, 10} into {3, -5, -5, 10}. The given code is buggy and does not behave correctly on all inputs.  There are some provided SimpleTest unit tests that demonstrate a few of the inputs that are problematic. Run those tests and observe which ones pass and which do not. The provided test cases include an input with no negative numbers, one with a single negative number, and another with some negative numbers. There is no test for a Queue of all negative numbers, so you decide to add one.  Add a STUDENT_TEST for this case.  Run the tests again. When running, it seems this new case is taking a really, really long time. In fact what has happened is that the program has entered an infinite loop and is never coming back. You will have to manually stop it. You can exit a stuck program by closing the console window or choosing \"Quit\" from the menu bar.  Some of the inputs works correctly, others complete and yet produce wrong output, and your new test shows there is also a third category, where some inputs go into an infinite loop.  When constructing tests and analyzing buggy code, it is important to really understand what kind of inputs cause specific problems, as that can help focus the debugging process. In this case, is the infinite loop triggered only if all numbers in the queue are negative or is there more to it? Try adding additional test cases to narrow down on the exact trigger.  Gather the results of your observations and answer the following questions in short_answer.txt:     Q2: What must be true about the input for the function to produce correct output?   Q3: For which type of inputs does the function go into an infinite loop?   Rather than identify a specific input, we would like you to describe the general characteristics of the respective inputs.  3) Debug stutterNegative  Now that you've observed the buggy behavior and know what kind of input triggers it, let's use the debugger to diagnose the flaw in the code. (You may have already seen the bug when reading over the code; if so, great! But the purpose of this exercise is to show you a methodology for using the debugger that will help you in later times when you cannot spot the bug just from reading the code.)  Identify one of the failing tests from above (in particular, one that causes an infinite loop may be particularly insightful). Set a breakpoint on the call to stutterNegative inside the test case and then run the tests in Debug mode. If you need to break out of an infinite loop along the way, you can use the Pause/Interrupt button of the debugger.  When the breakpoint is hit, step into the stutterNegative function call and then step until you are at the beginning of the for loop. At this point, expand the variable q to see its contents. Run through a few loop iterations and pay attention to the changing values for i and q. Can you use this information to explain why the loop never reaches its intended termination condition?  Answer the following question in short_answer.txt:     Q4. What is the bug within stutterNegative that causes it to get stuck in a loop?   Given the above detective work, you may have a fix in mind to apply to the stutterNegative code.  Try out that fix and see that it resolves the problem with the infinite loop inputs. As a followup, re-test inputs that previously terminated but with incorrect output. You should find they are also working correctly now. In this case, the same underlying flaw was producing two seemingly unrelated symptoms. Debugger use for the win!  4) Recognizing error  The last part of the warmup is learning how to recognize when a test case raises an error.  The function removeMatchPair is intended to modify a Map&lt;string, string&gt; to remove any pair where key == value.  Run the provided unit tests. It passes the first test that makes no change, but the subsequent test goes down in flames. The Map remove operation is raising an error because it is disallowed to add/remove elements in the midst of iterating over that collection. (If you think it through, you can see why this would be problematic….) Students very commonly run afoul of this restriction so we thought we'd get it on your radar before it trips you up.  When an error is raised by your code in the middle of a unit test, SimpleTest will report it with a message like the following:  Exception     Test failed due to the program triggering an ErrorException.      This means that the test did not fail because of a call     to EXPECT() or EXPECT_ERROR() failing, but rather because     some code explicitly called the error() function.      Error: Collection modified during iteration. Iterator is now invalid. Do not modify a collection during a for-each loop or iterator traversal.   When you see this message, it means a fatal error was raised when running the test and that error prevented the test from completing. The error was not expected. An error generally indicates a bug in your code where it attempts to perform an illegal operation such as accessing an out of bounds index or reading a non-existent file.  You follow the same debugging process for an error condition as a failing test case, set a breakpoint and step through the test to see what has gone wrong. There is one added twist that you can step up to, but not over, the actual crashing operation. If you step over an operation that crashes, the program exits and you lose all of your debugging information. You must re-start the program and step up to the crash again to regain that insightful debugging information.  "
